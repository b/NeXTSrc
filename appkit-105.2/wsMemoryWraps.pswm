/*
	wsMemoryWraps.pswm
	Copyright 1990, NeXT, Inc.
	Responsibility: Ali Ozer

	Author: Leo Hourvitz
*/

    
/*
This module defines the function NXGetWindowServerMemory(), which will return the amount of Window Server memory being used by the current Window Server context.

Synopsis:

int NXGetWindowServerMemory(DPSContext *context,
			int *vmUsedP, int *windowBackingP,
			NXStream *windowDumpStream);

NXGetWindowServerMemory() calculates the amount of Window Server memory being used at the moment by the given Window Server context.  If NULL is passed for the context, the current context is used.  The amount of VM used by the current context is r
eturned in the int pointed to by vmUsedP; the amount of window backing store used by windows owned by the current context is returned in the int pointed to by windowBackingP.  The sum of these two numbers is the amount of the Window Server)s memory
 that this context is responsible for.

To calculate these numbers, NXGetWindowServerMemory() uses the PostScript language operators dumpwindows and vmstatus.  It takes some time to execute; thus, calling this function in normal operation is not recommended.

If a non-NULL value is passed in for windowDumpStream, the information returned from the dumpwindows operator is echoed to the NXStream given.  This can be useful for finding out more about which windows are using up your storage.

Return Value

Normally, NXGetWindowServerMemory() returns 0.  If NULL is passed for context and there)s no current DPS Context, -1 is returned.

*/

#import <strings.h>
#import <stdlib.h>
#import <zone.h>
#import <streams/streams.h>
#import <dpsclient/dpsclient.h>

/* These three variables define a buffer filled by _NXMyTextProc
   below, and parsed by the NXWindowServerMemory() procedure. */

/* How can we get rid of these statics??? */

static char *responseBuffer;    /* Pointer to character buffer */
static int   responseBufCount;	/* Number of bytes in buffer, currently */
static int   responseBufSize;	/* Total size of buffer */

#define MINRESPBUFSIZE 500

/* Prototype for _NXMyTextProc; implementation is below
   NXWindowServerMemory() */

static void _NXMyTextProc(
	DPSContext context,
	char *buf,
	long unsigned int count);

/*
_NXvmstatus is a pswrap that calls the vmstatus operator after doing a private VM garbage collection.  You need to do a garbage collection in order to get consistent results from the vmstatus operator.
*/

defineps static vmstatus(DPSContext context|int *vmUsed)
	% First, make sure we get the status for our private VM
	currentshared false setshared
	% Do a private garbage collection
	1 vmreclaim
	% OK, get the answer
	vmstatus pop vmUsed pop
	% and restore the old shared state
	setshared
endps

int _NXGetDetailedWindowServerMemory (DPSContext context,
				  int *vmUsedP,
				  int *bufferedMem,
				  int *retainedMem,
				  int *fixedMem,
				  int *otherMem,
				  NXStream *windowDumpStream)
{
    int bytes;
    DPSTextProc oldTextProc;
    char *buf, *bufEnd, *newBuf, *colon;

    /* First, make sure that either there is a current context or
	we were passed one. */

    if ((context == NULL) && ((context = DPSGetCurrentContext()) == NULL)) {
	return -1;
    }

    /* Reset the character buffer variables */
    responseBuffer = NULL;
    responseBufSize = responseBufCount = 0;

    /* We'll get the Window Server VM used here.  Note that since 			
	the _NXvmstatus wrap function returns a result, it'll
	implicitly synchronize the given context.  This will make
	sure that all data in the buffers in either direction has
	been flushed, and that we can synchronously install our
	text proc. */

    vmstatus(context,vmUsedP);

    /* Now install our text proc.  We)re about to call the
	dumpwindows operator, which will write out a whole bunch of
	stuff on the output stream back to us.  We need to install
	our text proc before we do that, so that when the output
	comes out we will catch it.  Also, we remember the old text
	proc so we can put it back afterwards. */

    oldTextProc = context->textProc;
    DPSSetTextProc(context,_NXMyTextProc);

    /* Now call the dumpwindows operator, and our text proc
	catches all the responses and puts them in the
	reponseBuffer. */

    DPSPrintf(context,"0 currentcontext dumpwindows flush\n");

    /* Call DPSWaitContext to be sure we)re really done, and all
	of the responses are really in the responseBuffer. */

    DPSWaitContext(context);

    /* OK, now we)ve got all the text in responseBuffer.  We can
	take our text proc back out. */

    DPSSetTextProc(context,oldTextProc);

    /* The real work.  We get a line at a time out of
	reponseBuffer, and look at it to see if it looks like a
	line generated by the dumpwindows operator.  If so, we
	parse the memory usage number out of it; if not, we pass it
	to the old text proc for whatever normal processing
	occurs. */

    if (responseBuffer)
    {
	buf = responseBuffer;
	bufEnd = buf + responseBufCount + 1;
	*bufferedMem = *retainedMem = *fixedMem = *otherMem = 0;

	while(buf < bufEnd) {
	
	    /* Find a line & Null-terminate it. We need the newline */
	    newBuf = index(buf,'\n');
	    if (!newBuf) break;
	    *newBuf = 0;
	    /* Parse the line. dumpwindows returns lines that look like:
	     *
	     * Buffered: (0,448),(672,832) 129024+ bytes (131072)
	     *
	     * where the "+" is optional.
	     */
	    if ((colon = index(buf, ':')) &&
		(sscanf(colon+1," (%*d,%*d),(%*d,%*d) %d%*c%*s (%*d)", 
		&bytes) == 1)) {
		*colon = 0;		    
		if (!strcmp(buf,"Fixed")) *fixedMem += bytes;
		else if (strcmp(buf,"Retained")) *retainedMem += bytes;
		else if (strcmp(buf,"Buffered")) *bufferedMem += bytes;
		else *otherMem += bytes;
		*colon = ':';
		if (windowDumpStream) {
		    NXPrintf(windowDumpStream,"%s\n",buf);
		}
	    } else {
		(*oldTextProc)(context,buf,strlen(buf));
	    }
	    buf = newBuf + 1;
	} /* while(buf < bufEnd) */
		
	/* Free the buffer */

	free(responseBuffer);
    }

    return 0;

} /* NXWindowServerMemory() */

int NXGetWindowServerMemory(DPSContext context,
			    int *vmUsedP,
			    int *windowBackingP,
			    NXStream *windowDumpStream)
{
    int bufferedMem, retainedMem, fixedMem, otherMem;
    int result = _NXGetDetailedWindowServerMemory (context, vmUsedP,
			&bufferedMem, &retainedMem, &fixedMem, &otherMem,
			windowDumpStream);
    if (result == 0) {
	*windowBackingP = bufferedMem + retainedMem + fixedMem + otherMem;
    }
    return result;
}

/* Implementation of _NXMyTextProc.  All that _NXMyTextProc does
   is accumulate all the text that comes in on the context while
   it's active into responseBuffer, resizing it when
   necessary.  It's left to NXWindowServerMemory() to parse the
   stuff out afterwards.  */

static void _NXMyTextProc(DPSContext context, char *buf, unsigned long count)
{
    /* Expand the buffer if necessary */

    while((count + responseBufCount + 1) > responseBufSize)
    {	/* Must expand buffer */
	if (responseBuffer == NULL)
	{
	    responseBuffer=NXZoneMalloc(NXDefaultMallocZone(),MINRESPBUFSIZE);
	    responseBufSize = MINRESPBUFSIZE;
	}
	else
	{
	    responseBuffer = NXZoneRealloc(NXDefaultMallocZone(), 
					   responseBuffer,responseBufSize*2);
	    responseBufSize *= 2;
	}
    }

    /* Put the new data in the buffer and update the count */

    bcopy(buf,responseBuffer+responseBufCount,count);
    responseBufCount += count;

    /* And null-terminate the buffer (this is used by the main procedure) */

    *(responseBuffer+responseBufCount) = 0;
} /* _NXMyTextProc */


/*

NXWindowServerMemory() originally written by Leo Hourvitz for developer use.

86
--
 6/11/90 aozer	Updated to use the 2.0 dumpwindows output (which says window
		type instead of just "Layer:") and made part of the kit.
 6/11/90 aozer	Put "Get" in the name (NXWindow...->NXGetWindow) and also
		added _NXGetDetailedWindowServerMemory().

90
--
 8/4/90 aozer	Zonified.

*/
