/*
 *  autodiskmount
 *	Launched by /etc/rc to respond to insert events generated by disk insertion.
 *	Communicates with the Workspace to handle disk related actions which must
 *	be performed setuid root.
 *
 *	John Seamons, NeXT Inc.
 *
 *  HISTORY
 * 13-Jul-90  John Seamons (jks) at NeXT.
 *	Handle OD_EJECT option correctly when mounting a disk.
 * 26-Jul-90  Lee Boynton (lboynton) at NeXT.
 *	Added support to send the device name and type strings to Workspace. Fixed bugs.
 * 16-Aug-90  Lee Boynton (lboynton) at NeXT.
 *	Added message id to differentiate between 'mount new device' and 'mount this device'
 *	Added support to queue insertion messages if Workspace was not yet running.
 */
 
#define	ADM_DEBUG	1
#define	KERNEL_FEATURES	1

#import <sys/types.h>
#import <sys/errno.h>
#import <sys/file.h>
#import <sys/signal.h>
#import <sys/stat.h>
#import <sys/dir.h>
#import <sys/param.h>
#import <sys/message.h>
#import <ufs/fs.h>
#import <nextdev/dma.h>
#import <nextdev/disk.h>
#import <nextdev/video.h>
#import <mon/nvram.h>
#import <stdio.h>
#import <mntent.h>
#import <pwd.h>
#import <syslog.h>
#import <servers/netname.h>
#import "automountmessage.h"
#import <nextdev/insertmsg.h>

#define	TRUE		1
#define	FALSE		0
#define DEVNAMESIZE	32
#define HOSTNAMESIZE	256
#define	VOL0		"/dev/vol0"
#define	VID0		"/dev/vid0"
#define	VOL(dev)	(minor(dev) >> 3)
#define PART(dev)	(minor(dev) & 7)
#define	MINOR(vol, part) (((vol) << 3) | (part))
#define	MINOR_CTRL	255
#define	NDEVNAME	8
#define	REPLY_TIMEOUT	0 /* FIXME(60*1000)		/* 60 seconds */

int 	singleDiskSystem;
char	raw_part[DEVNAMESIZE];
char	*DiskName = "Disk";
int     userId;
int	ctrl_fd = -1;
port_t	reply_port;
extern	int errno;
struct	stat root;
enum	am_type {AM_TYPE_DEV, AM_TYPE_PORT};
extern	port_t name_server_port;
int	debug;

int automount (enum am_type type, 
	dev_t dev, 
	port_t port, 
	int state, 
	char *args, 
	char *dev_name, 
	int removable,
	int read_only);
int etc_mount(char *name, char *dir, int read_only);

char *err_list[] = {
	"disk initialization failed",
	"mount point must not already exist",
	"unable to fsck disk",
	"no file system on partition or super block corrupted",
	"message communication error",
	"illegal characters in disk label name",
	"no disk volumes available",
	"repair disk on a two drive system",
	"initialize disk on a two drive system",
};

/*
 * This structure is used to build a list of mntent structures
 * as copy of /etc/mtab.
 */
struct mntlist {
	struct mntent *mntl_mnt;
	struct mntlist *mntl_next;
} *mountList, *mkmntlist();

struct am_message am_message_prototype = {
	{0, FALSE, sizeof(struct am_message), MSG_TYPE_NORMAL, 0, 0, 0},
	{MSG_TYPE_INTEGER_32, sizeof(int)*8, 1, TRUE, FALSE, FALSE},
	0,
	{MSG_TYPE_PORT, sizeof(port_t)*8, 1, TRUE, FALSE, FALSE},
	0,
	{MSG_TYPE_INTEGER_32, sizeof(u_int)*8, 1, TRUE, FALSE, FALSE},
	0,
	{MSG_TYPE_INTEGER_32, sizeof(int)*8, 1, TRUE, FALSE, FALSE},
	0,
	{MSG_TYPE_INTEGER_32, sizeof(int)*8, 1, TRUE, FALSE, FALSE},
	0,
	{MSG_TYPE_CHAR, sizeof(char)*8, MAXLBLLEN, TRUE, FALSE, FALSE},
	{0},
	{MSG_TYPE_CHAR, sizeof(char)*8, MAXPATHLEN, TRUE, FALSE, FALSE},
	{0},
	{MSG_TYPE_CHAR, sizeof(char)*8, MAXARGS, TRUE, FALSE, FALSE},
	{0},
	{MSG_TYPE_CHAR, sizeof(char)*8, OID_DEVSTR_LEN, TRUE, FALSE, FALSE},
	{0},
};

controller (dev, dev_name)
	dev_t dev;
	char *dev_name;
{
	int fd;
	char fn[32];

	sprintf (fn, "/dev/%c%cc0", dev_name[0], dev_name[1]);
	log ("controller: %s\n", fn);
	if ((fd = open (fn, O_RDONLY)) < 0) {
		panic(fn);
		return (-1);
	}
	return (fd);
}

free_vol (dev, dev_name, vol)
	dev_t *dev;
	char *dev_name;
	int *vol;
{
	if (ctrl_fd == -1 && (ctrl_fd = controller (*dev, dev_name)) < 0)
		return (-1);
	if (ioctl (ctrl_fd, DKIOCGFREEVOL, vol) < 0) {
		panic("DKIOCGFREEVOL");
		return (-1);
	}
	*dev = makedev(major(*dev), MINOR(*vol, 0));
	return (0);
}

raw_dev (dev, dev_name)
	dev_t dev;
	char *dev_name;
{
	int fd;
	char fn[32];
	
	sprintf (fn, "/dev/r%s%c", dev_name, PART(dev) + 'a');
	log ("raw_dev: %s\n", fn);
	if ((fd = open (fn, O_RDONLY)) < 0) {
		panic(fn);
		return (-1);
	}
	/* XXX validate dev is a removable drive? */
	return (fd);
}

raw_dev_no_block (dev, dev_name)
	dev_t dev;
	char *dev_name;
{
	int fd;
	char fn[32];
	
	sprintf (fn, "/dev/r%s%c", dev_name, PART(dev) + 'a');
	log ("raw_dev: %s\n", fn);
	if ((fd = open (fn, O_RDONLY|O_NDELAY)) < 0) {
		panic(fn);
		return (-1);
	}
	/* XXX validate dev is a removable drive? */
	return (fd);
}

int	locked = 0;     /* have we locked out other processes? */

lock()
{
	if (locked)
		return (0);
	if (ioctl (ctrl_fd, DKIOCSDCLOCK) < 0) {
		panic ("DKIOCSDCLOCK");
		return (-1);
	}
	locked = 1;
	return (1);
}

unlock()
{
	if (!locked)
		return (0);
	if (ioctl (ctrl_fd, DKIOCSDCUNLOCK) < 0) {
		panic ("DKIOCSDCUNLOCK");
		return (-1);
	}
	locked = 0;
	return (1);
}

allow_eject()
{
	int fd;
	struct nvram_info ni;
	
	if ((fd = open (VID0, O_RDONLY)) < 0) {
		panic (VID0);
		return (-1);
	}
	if (ioctl (fd, DKIOCGNVRAM, &ni) < 0) {
		close (fd);
		panic ("get NVRAM");
		return (-1);
	}
	close (fd);
	if (ni.ni_hw_pwd == HW_PWD && ni.ni_allow_eject == 0)
		return (0);
	return (1);
}

eject (dev, dev_name)
	dev_t dev;
	char *dev_name;
{
	int fd, err=-1;
	
	/* prevent locked opticals from being ejected */
	if (strncmp(dev_name, "od", 2) == 0 && (err = allow_eject()) < 0)
		return (-1);
	if (err == 0)
		return (0);
	if ((fd = raw_dev_no_block (dev, dev_name)) < 0)
		return (-1);
	err = eject_fd (fd);
	close (fd);
	return (err);
}

eject_fd (fd)
{
	if (ioctl (fd, DKIOCEJECT) < 0) {
		panic ("eject");
		return (-1);
	}
	return (0);
}

sd_mount (dev, dev_name, mntpt, r)
	dev_t dev;
	char *dev_name;
	char *mntpt;
	struct am_message *r;
{
	char s[MAXPATHLEN+1], name[DEVNAMESIZE];
	int err = -1, npart, not_unique = 0, e, vol;
	FILE *mf;
	struct mntent *mnt;
        struct mntlist *mntl;
	int slen;
	
	mountList = mkmntlist(MOUNTED);
	if (!mountList) {
		panic(MOUNTED);
		goto exitPoint1;
	}
	if (free_vol (&dev, dev_name, &vol) < 0)
		goto exitPoint;
	if (vol < 0) {
		errno = E_NOVOL;
		panic(0);
		goto exitPoint;
	}
	slen = strlen (DiskName);
	for (mntl = mountList;mntl;mntl = mntl->mntl_next) {
		mnt = mntl->mntl_mnt;
		if (mnt && !strncmp (rindex (mnt->mnt_dir, '/') + 1,
		    DiskName,slen))
			not_unique = 1;
	}
		
	sprintf (raw_part, "/dev/r%sa", dev_name);
	sprintf (s, "%s/%s", mntpt, DiskName);
	strncpy(r->label, DiskName, MAXLBLLEN);
	if (access (s, F_OK) == 0) {
		errno = E_MNTPT;
		panic(0);
		goto exitPoint;
	}
	sprintf (name, "/dev/%sa", dev_name);
	if (lock() < 0)
		goto exitPoint;
	initItems(1);
	if ((errno = etc_mount (name, s, 0)) == -1) {
		un_mount (dev, dev_name);
		errno = E_2DRIVE;
		panic(0);
		goto exitPoint;
	} else
	if (e == ENXIO) {
		errno = E_2INIT;
		panic(0);
		goto exitPoint;
	} else
	if (errno > 0) {
		panic ("mount");
		goto exitPoint;
	}
	writePlaces();
	err = 0;
exitPoint:
	freemntlist(mountList);
exitPoint1:
	unlock();
	return (err);
}

static
initDisk(dev_name, vol, label, args)
	char *dev_name, *label, *args;
{
	char hostname[HOSTNAMESIZE];
	
	gethostname (hostname, sizeof (hostname));
	if (sys ("/usr/etc/disk -i -h %s -l \"%s\" %s /dev/r%sa",
	    hostname, label, args, dev_name)) {
	    	errno = E_INITFAIL;
		panic("initDisk");
		return (-1);
	}
	return (0);
}

init (m)
	struct am_message *m;
{
	int fd = -1, err = 0;
	
	if ((fd = raw_dev (m->dev, m->dev_name)) < 0) {
		goto exitError;
	}
	un_mount (m->dev, m->dev_name);
        if (initDisk(m->dev_name, VOL(m->dev), m->label, m->args))     
		goto exitEject;
	goto exitPoint;
exitEject:
	eject_fd (fd);
exitError:
	err = -1;
exitPoint:
	if (fd >= 0)
		close (fd);
	return (err);
}

validate_diskname (from, to)
	char *from, *to;
{
	int i;
	
	for (i = 0; *from && i < MAXLBLLEN; from++, i++) {
		if (*from != '/' && *from != '"')
			*to++ = *from;
	}
	*to++ = 0;
}

int automount (enum am_type type, 
	dev_t dev, 
	port_t port, 
	int state, 
	char *args, 
	char *dev_name, 
	int removable,
	int read_only)
{
	char s[MAXPATHLEN+1], name[DEVNAMESIZE], diskname[MAXLBLLEN];
	char sblock[SBSIZE + DMA_BEGINALIGNMENT];
	struct fs *fs = DMA_ALIGN(struct fs*, sblock);
	int fd = -1, i, vol;
	struct disk_label dl;
	int slen;
	int firstCall, firstFsck;
	port_t am_port;
	struct am_message am_m, *m = &am_m, am_r, *r = &am_r;


	/* lookup workspace port each time in case Workspace has restarted */
	if (errno = -netname_look_up(name_server_port, "",
	    AUTODISKMOUNT_WORKSPACE, &am_port)) {
		panic("netname_look_up: %s", AUTODISKMOUNT_WORKSPACE);
		return -1;
	}
	if (!(mountList = mkmntlist(MOUNTED)))
		fatal(MOUNTED);

	if (minor(dev) == MINOR_CTRL) {
		if (free_vol (&dev, dev_name, &vol) < 0)
			goto exitPoint;
		if (vol < 0) {
			errno = E_NOVOL;
			panic(0);
			goto exitPoint;
		}
	} else
		vol = VOL(dev);
	
	if ((fd = raw_dev (dev, dev_name)) < 0)
		goto exitPoint;
	
	sprintf (name, "/dev/%sa", dev_name);
	sprintf (raw_part, "/dev/r%sa", dev_name);
	
	/* If this device appears in fstab, abort. Note that mountList 
	 * contains mounted devices (from /etc/mtab)...
	 */
	if(minor(dev) != MINOR_CTRL) {
		struct mntent *mnt;
		FILE *mounted;
		
		mounted = setmntent(MNTTAB, "r");
		if (mounted == NULL) {
			panic (MOUNTED);
			goto exitPoint;
		}
		while ((mnt = getmntent(mounted)) != NULL) {
			if (!strcmp (name, mnt->mnt_fsname)) {
				log("Ignoring automount of %s (in fstab)\n ",
					name);
				goto exitPoint;
			}
		}
		endmntent (mounted);
	}

	*m = am_message_prototype;
	m->dev = dev;
	strcpy(m->dev_name, dev_name);
	if(removable)
		m->flags |= REMOVABLE;
	else
		m->flags &= ~REMOVABLE;
	if(read_only)
		m->flags |= READ_ONLY;
	else
		m->flags &= ~READ_ONLY;

	/* try to read label information */
	if (state != IND_VS_LABEL) {
		strcpy(m->args, args);
		m->flags |= REQUIRES_INIT;
		if (state == IND_VS_UNFORMATTED)
			m->flags |= NO_FORMAT;
		send_msg(m, AM_INSERT, am_port, reply_port);
		if (recv_msg(r, AM_INSERT | MSG_REPLY, reply_port, REPLY_TIMEOUT) < 0)
			goto exitError;
		if (r->flags & DO_NOT_MOUNT)
			goto exitPoint;
		if (r->flags & DO_EJECT)
			goto exitEject;
		if (!(r->flags & DO_INIT))
			goto exitPoint;
do_init:
		if (r->label[0] == 0)
			strcpy(r->label, DiskName);
		if (initDisk(dev_name, vol, r->label, r->args))
			goto exitError;
		if (ioctl (fd, DKIOCGLABEL, &dl) < 0) {
			panic("DKIOCGLABEL");
			goto exitError;
		}
		goto mount_it;
	} else {
		if (ioctl (fd, DKIOCGLABEL, &dl) < 0) {
			panic("DKIOCGLABEL");
			goto exitError;
		}
	}
	validate_diskname (&dl.dl_label, &diskname);
	slen = strlen (diskname);
	if (slen == 0) {
		strcpy (diskname, DiskName);
		slen = strlen (diskname);
	}
	strncpy(m->label, diskname, MAXLBLLEN);
	strncpy(m->mntpt, &dl.dl_dt.d_name, MAXDNMLEN); //LRB 29Jul90
	strncpy(m->args, &dl.dl_dt.d_type, MAXTYPLEN); //LRB 29Jul90
	if (lseek(fd, dbtob(SBLOCK), L_SET) < 0) {
		panic("lseek");
		goto exitError;
	}
	if (read(fd, fs, SBSIZE) < 0) {
		panic("read");
		goto exitError;
	}
	if (fs->fs_state != FS_STATE_CLEAN)
		m->flags |= REQUIRES_FSCK;
	send_msg(m, AM_INSERT, am_port, reply_port);
	if (recv_msg(r, AM_INSERT | MSG_REPLY, reply_port, REPLY_TIMEOUT) < 0)
		goto exitError;
	if (r->flags & DO_NOT_MOUNT)
		goto exitPoint;
	if (r->flags & DO_EJECT)
		goto exitEject;
	if (r->flags & DO_INIT)
		goto do_init;
mount_it:
    	userId = r->uid;
	firstCall = 1;
	if (access (r->mntpt, F_OK) == 0) {
		errno = E_MNTPT;
		panic(0);
		goto exitError;
	}
	firstFsck = 1;
mountit2:
	initItems(firstCall);
	firstCall = 0;
	if ((errno = etc_mount (name, r->mntpt, read_only)) == -1) {
		singleDiskSystem = 1;
		un_mount (dev, dev_name);
		singleDiskSystem = 0;
		if (!firstFsck) {
			errno = E_FSCK;
			panic(0);
			goto exitError;
		}
		if (sys ("/usr/etc/fsck -p /dev/r%sa", dev_name))
			if (sys ("/usr/etc/fsck -p /dev/r%sa", dev_name)) {
				errno = E_FSCK;
				panic(0);
		    		goto exitError;
		    }
		firstFsck = 0;
		goto mountit2;
	} else if (errno > 0) {
		if (errno == EBADF || errno == ENXIO || errno == EBUSY) {
			errno = E_BADFS;
			panic(0);
		} else
			panic("mount");
		goto exitError;
	}
	writePlaces();
	*m = am_message_prototype;
	m->dev = dev;
	strcpy(m->dev_name, dev_name);
	send_msg(m, AM_MOUNTED, am_port, PORT_NULL);
	goto exitPoint;
exitError:
	*m = am_message_prototype;
	m->dev = dev;
	strcpy(m->dev_name, dev_name);
	m->errno = errno;
	send_msg(m, AM_MOUNTED, am_port, PORT_NULL);
exitEject:
	eject_fd (fd);
exitPoint:
	/* close must be after mount so the volume isn't deallocated early */
	if (fd >= 0)
		close (fd);
	freemntlist(mountList);
	return 0;
}

un_mount (dev, dev_name)
	dev_t dev;
	char *dev_name;
{
	int fd;
	char fsname[DEVNAMESIZE];
	FILE *mf;
	struct mntent *mnt;
        struct mntlist *mntl;
        struct mntlist *firstmnt;

	int points, err = -1, ejectAfter;
	
	sprintf (fsname, "/dev/%s", dev_name);
	log ("un_mount %s\n", fsname);
	firstmnt = mkmntlist(MOUNTED);
	if (!firstmnt) {
		panic (MOUNTED);
		return (-1);
	}

        points = 0;
	for (mntl = firstmnt;mntl;mntl = mntl->mntl_next) {
		mnt = mntl->mntl_mnt;
		
		/* unmount each partition of the volume */
		if (strncmp (fsname, mnt->mnt_fsname, strlen (fsname)) != 0) {
			continue;
		}
		points++;
	}
	for (mntl = firstmnt;mntl;mntl = mntl->mntl_next) {
		mnt = mntl->mntl_mnt;
		
		/* unmount each partition of the volume */
		if (strncmp (fsname, mnt->mnt_fsname, strlen (fsname)) != 0) {
			continue;
		}
		log ("unmount %s\n", mnt->mnt_fsname);
		points--;
		ejectAfter = 0; /*!(singleDiskSystem || points)*/
		if (errno = umount(mnt->mnt_fsname, ejectAfter, dev)) {
			if (errno != EBUSY) {
				panic ("unmount");
				goto exitPoint;
			}
			
			/* TODO: figure out which apps are using disk */
			log ("%s: EBUSY\n", mnt->mnt_fsname);
			panic ("unmount");
			goto exitPoint;
		}
	}
	err = 0;
exitPoint:
	freemntlist(firstmnt);
	return (err);
}

set_label (m, r)
	struct am_message *m, *r;
{
	int fd, i;
	struct disk_label dl;

	for (i = 0; m->label[i] && i < MAXLBLLEN; i++) {
		if (m->label[i] == '"' || m->label[i] == '/') {
			errno = E_LABEL;
			panic(0);
			return (-1);
		}
	}
	if ((fd = raw_dev (m->dev, m->dev_name)) < 0)
		return (-1);
	if (ioctl (fd, DKIOCGLABEL, &dl) < 0) {
		panic("GLABEL");
		close(fd);
		return (-1);
	}
	if (dl.dl_label_blkno != 0) {
		log ("DKIOCGLABEL returned with dl_label_blkno = %d\n", dl.dl_label_blkno);
		dl.dl_label_blkno = 0;
	}
	strncpy (dl.dl_label, m->label, MAXLBLLEN);
	if (ioctl (fd, DKIOCSLABEL, &dl) < 0) {
		panic("SLABEL");
		close(fd);
		return (-1);
	}
	close(fd);
	return (0);
}

get_label (m, r)
	struct am_message *m, *r;
{
	int fd;
	struct disk_label dl;
	
	if ((fd = raw_dev (m->dev, m->dev_name)) < 0)
		return (-1);
	if (ioctl (fd, DKIOCGLABEL, &dl) < 0) {
		panic("GLABEL");
		close(fd);
		return (-1);
	}
	close(fd);
	strncpy(r->label, dl.dl_label, MAXLBLLEN);
	return (0);
}

#define MAX_PENDING_INSERTIONS (256)

main (argc, argv)
	char *argv[];
{
	int dev, fd;
	struct stat sb;
	port_t wm_port, sig_port, notify_port;
	port_set_name_t recv_port_set;
	struct am_message m, r;
	struct of_insert_notify_dev *pending_oids[MAX_PENDING_INSERTIONS] = {0};
	int pending_count=0;
	struct of_insert_notify_dev *oid = (struct of_insert_notify_dev*) &m;
	struct of_insert_notify_port *oip = (struct of_insert_notify_port*) &m;
	
	if (argc > 1) {
		debug = 1;
		openlog("autodiskmount", LOG_PID, LOG_DAEMON);
	}
	if (stat ("/", &root) < 0)
		fatal("/");
	if (errno = -port_allocate(task_self(), &reply_port))
		fatal("reply_port");
	if (errno = -port_allocate(task_self(), &sig_port))
		fatal("sig_port");
	if (errno = -port_allocate(task_self(), &wm_port))
		fatal("wm_port");
	if (errno = -port_allocate(task_self(), &notify_port))
		fatal("notify_port");
	if (errno = -netname_check_in(name_server_port,
	    WORKSPACE_AUTODISKMOUNT, sig_port, wm_port))
		fatal("netname_check_in");
	
	/* use a port set to listen to kernel and Workspace simultaneously */
	if (errno = -port_set_allocate(task_self(), &recv_port_set))
		fatal("port_set_allocate");
	if (errno = -port_set_add(task_self(), recv_port_set, wm_port))
		fatal("port_set_add");
	if (errno = -port_set_add(task_self(), recv_port_set, notify_port))
		fatal("port_set_add");
	
	while (1) {
		if (recv_msg(&m, 0, recv_port_set, 0))
			continue;
		r = am_message_prototype;
		r.dev = m.dev;
		strcpy(r.dev_name, m.dev_name);

		log ("received type %d\n", m.header.msg_id);
    		userId = m.uid;
		
		switch (m.header.msg_id) {

		/* sent by kernel when an insert event occurs */
		case VOL_CHECK_MSG_ID:
		    if (oid->oid_header.in_dev_desc == IND_DD_DEV) {
			if (automount(AM_TYPE_DEV, oid->oid_bdev_t, 0,
					oid->oid_header.in_vol_state,
					oid->oid_header.in_form_type,
					oid->oid_dev_str,
					oid->oid_header.in_flags & 
						IND_FLAGS_REMOVABLE,
					oid->oid_header.in_flags & 
						IND_FLAGS_WP)) {
				struct of_insert_notify_dev 
					*pending_oid;
					
				pending_oid = (struct of_insert_notify_dev *)
					malloc
					(sizeof(struct of_insert_notify_dev));
				*pending_oid = *oid;
				pending_oids[pending_count++] = pending_oid;
			}
		    } else {
			    /* XXX automount is heavily "dev" dependent */
			    /*automount(AM_TYPE_PORT, 0, oip->oip_port,
				    oip->oip_header.in_vol_state,
				    oip->oip_header.in_form_type, ?dev_str?);*/
		    }
		    break;
		
		/* sent by Workspace when launched -- enable insert event reporting */
		case WM_NOTIFY:
			if ((fd = open(VOL0, O_RDWR, 0)) < 0)
				fatal(VOL0);
			if (ioctl(fd, DKIOCMNOTIFY, &notify_port) < 0)
				fatal("DKIOCMNOTIFY");
			if (ioctl(fd, DKIOCPANELPRT, 
			    &m.header.msg_remote_port) < 0)
				fatal("DKIOCPANELPRT");
			close(fd);
			break;

		/* the rest of these are sent by the Workspace... */
		case WM_UNMOUNT:
			if (un_mount(m.dev, m.dev_name) < 0)
				r.errno = errno;
			break;
			
		case WM_NEWMOUNT:
			if (automount(AM_TYPE_DEV, 
			    makedev(major(m.dev), MINOR_CTRL), 0, 0, 0,
			    m.dev_name, m.flags & REMOVABLE,
			    m.flags & READ_ONLY) < 0)
				r.errno = errno;
			break;

		case WM_MOUNT:
			if (automount(AM_TYPE_DEV, m.dev, 0, 0, 0, m.dev_name,
			    m.flags & REMOVABLE, m.flags & READ_ONLY) < 0)
				r.errno = errno;
			break;
			
		case WM_EJECT:
		
			/* trying to eject rootdev causes single disk mount */
			if (m.dev == root.st_dev) {
				if (sd_mount(m.dev, m.dev_name, m.mntpt, &r) < 0)
					r.errno = errno;
			} else {
				if (eject(m.dev, m.dev_name) < 0)
					r.errno = errno;
			}
			break;
			
		case WM_INIT:
			if (init(&m) < 0)
				r.errno = errno;
			break;
			
		case WM_GETLABEL:
			if (get_label(&m, &r) < 0)
				r.errno = errno;
			break;
			
		case WM_SETLABEL:
			if (set_label(&m, &r) < 0)
				r.errno = errno;
			break;
			
		default:
			log ("unknown type 0x%x\n", m.header.msg_id);
			r.errno = E_MSG;
			break;
		}
		
		/* send reply */
		if (m.header.msg_id != VOL_CHECK_MSG_ID)
			send_msg(&r, m.header.msg_id | MSG_REPLY,
				m.header.msg_remote_port, PORT_NULL);
		if (m.header.msg_id == WM_NOTIFY) {
			while (pending_count) {
				struct of_insert_notify_dev *pending_oid = 
					pending_oids[--pending_count];
				
				automount(AM_TYPE_DEV, pending_oid->oid_bdev_t,
				   0, pending_oid->oid_header.in_vol_state,
				   pending_oid->oid_header.in_form_type,
				   pending_oid->oid_dev_str,
  				   pending_oid->oid_header.in_flags &
					IND_FLAGS_REMOVABLE,
				   pending_oid->oid_header.in_flags &
					IND_FLAGS_WP);
				free(pending_oids[pending_count]);
				pending_oids[pending_count] = NULL;
			}
		}

		/* simulate disk insert after init completes */
		if (m.header.msg_id == WM_INIT && r.errno == 0) {
			automount (AM_TYPE_DEV, m.dev, 0, 0, 0, m.dev_name,
				m.flags & REMOVABLE,m.flags & READ_ONLY);
		}
		close (ctrl_fd);
		ctrl_fd = -1;
	}
}

sys (cmd, p1, p2, p3, p4, p5, p6, p7, p8, p9)
	char *cmd;
{
	char s[256];

	sprintf (s, cmd, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	log ("%s\n", s);
	return (system (s));
}

#if	ADM_DEBUG
pmsg (s, m)
	char *s;
	struct am_message *m;
{
	log("%s: 0x%x: dev 0x%x flags 0x%x uid %d errno %d label <%s> mntpt <%s> dev_name <%s>\n",
		s, m->header.msg_id, m->dev, m->flags,
		m->uid, m->errno, m->label, m->mntpt, m->dev_name);
}
#endif	ADM_DEBUG

int send_msg (m, type, rport, lport)
	struct am_message *m;
{
	m->header.msg_local_port = lport;
	m->header.msg_remote_port = rport;
	m->header.msg_id = type;
#if	ADM_DEBUG
	pmsg("send", m);
#endif	ADM_DEBUG
	if (errno = -msg_send((msg_header_t *)m, SEND_TIMEOUT | SEND_SWITCH, 120000)) {
		panic("msg_send");
		return (-1);
	}
        return (0);
}

int recv_msg (m, type, lport, timeout)
        struct am_message *m;
{
	m->header.msg_local_port = lport;
	m->header.msg_size = sizeof(struct am_message);
	if (errno = -msg_receive((msg_header_t *)m, timeout? RCV_TIMEOUT : MSG_OPTION_NONE, timeout)) {
		panic("msg_receive");
		return (-1);
	}
#if	ADM_DEBUG
	pmsg("recv", m);
#endif	ADM_DEBUG
	if (type && m->header.msg_id != type) {
		panic("recv_msg: got type 0x%x, expected 0x%x",
			m->header.msg_id, type);
		return (-1);
	}
	return (0);
}

extern int sys_nerr;
extern char *sys_errlist[];

panic (s, p1, p2, p3, p4)
	char *s;
{
	char *errs;
	char eb1[256], eb2[256];
        int  waslocked;
	
	waslocked = locked;
	if (waslocked && unlock() < 0)
		return;
	errs = "unknown error code";
	if (errno > 0 && errno <= sys_nerr)
		errs = sys_errlist[errno];
	else
	if (errno < 0) {
		errno = -errno;
		errs = (char*) mach_errormsg((kern_return_t) errno);
	} else
	if (errno >= E_START && errno < E_END)
		errs = err_list[errno - E_START];
	if (s)
		sprintf(eb1, s, p1, p2, p3, p4);
	if (errno)
		sprintf(eb2, "%s%s%s (%d)", s? eb1 : "", s? ": " : "", errs, errno);
	log("%s\n", eb2);
	if (waslocked)
		lock();
}

fatal (errno, s, p1, p2, p3, p4)
	char *s;
{
	panic(errno, s, p1, p2, p3, p4);
	exit (-1);
}

log (s, p1, p2, p3, p4, p5, p6, p7, p8, p9)
	char *s;
{
	int waslocked;

	if (singleDiskSystem)
		return;
	waslocked = locked;
	if (waslocked && unlock() < 0)
		return;
	
	printf (s, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	if (debug)
		syslog (LOG_ERR, s, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	
	if (waslocked && lock() < 0)
		return;
}

