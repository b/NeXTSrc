Only in sendmail.target: .places
Only in sendmail.target: FILES
Only in sendmail.target: Makedep
diff -r sendmail.target/Makefile sendmail/Makefile
1c1,19
< DIR=	usr.ucb/sendmail
---
> #
> # Copyright (c) 1988 The Regents of the University of California.
> # All rights reserved.
> #
> # Redistribution and use in source and binary forms are permitted
> # provided that the above copyright notice and this paragraph are
> # duplicated in all such forms and that any documentation,
> # advertising materials, and other materials related to such
> # distribution and use acknowledge that the software was developed
> # by the University of California, Berkeley.  The name of the
> # University may not be used to endorse or promote products derived
> # from this software without specific prior written permission.
> # THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
> # IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
> # WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
> #
> #	@(#)Makefile	4.15 (Berkeley) 1/19/89
> #
> SUBDIR=	src aux
3c21
< SUBDIR=	aux cf lib src
---
> all: ${SUBDIR}
5,12c23,24
< all clean depend tags: ALWAYS
< 	@echo '#################' make $@ for $(DIR) '###################'
< 	@for i in ${SUBDIR}; \
< 	do \
< 		echo ================= make $@ for $$i =================; \
< 		(cd $$i; ${MAKE} $@ || exit 1); \
< 	done
< 	@echo '#################' make $@ for $(DIR) done '###################'
---
> ${SUBDIR}: FRC
> 	cd $@; make ${MFLAGS}
14,22c26,27
< install: ALWAYS
< 	@echo '#################' make $@ for $(DIR) '###################'
< 	@CWD=`pwd`; cd ${DSTROOT}; DSTROOT=`pwd`; cd $$CWD; \
< 	for i in ${SUBDIR}; \
< 	do \
< 		echo ================= make $@ for $$i =================; \
< 		(cd $$i; ${MAKE} DSTROOT=$$DSTROOT $@ || exit 1); \
< 	done
< 	@echo '#################' make $@ for $(DIR) done '###################'
---
> clean cleandir depend install: FRC
> 	for i in ${SUBDIR}; do (cd $$i; make ${MFLAGS} $@); done
24c29
< ALWAYS:
---
> FRC:
Only in sendmail.target: NeXT_NFS.grep
Only in sendmail.target: README_FOR_NAME_SERVER
diff -r sendmail.target/READ_ME sendmail/READ_ME
0a1,18
> /*
>  * Copyright (c) 1988 The Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  *
>  *	@(#)READ_ME	4.2 (Berkeley) 1/19/89
>  */
2,64c20,24
< 			S E N D M A I L
< 
< Presumably by the time you get to this READ_ME file, you will have
< already read the tape in, or will have received this distribution as
< part of 4.2bsd.  If you do not yet have the distribution online, read
< the tape in now -- you will need about one megabyte to hold the tape.
< 
< The first thing you should look at is the documentation.  The two
< critical documents are "doc/intro.me" and "doc/op.me".  Read both
< of these before proceeding with your installation.  If you have read
< these before, you should still read through the second one again
< anyhow, since the installation procedures change occasionally.
< 
< A brief tour:
< 	FILES	  A list of the files on the tape.
< 	Makefile  A Makefile that will do a vanilla install for you.
< 	adb	  A set of adb(1) scripts for printing out certain
< 		  sendmail data structures.
< 	adm	  Administrativia.
< 	aux	  Files that represent programs that are not really
< 		  "part" of sendmail, or old versions of some files
< 		  in src for use by people on other system types.
< 	cf	  The configuration files for Berkeley, plus a few
< 		  prototype configurations for basic installation
< 		  types.
< 	doc	  The documentation.
< 	include	  The include files used by more than just the sendmail
< 		  program itself.
< 	lib	  Library routines used by sendmail, but not really
< 		  "part" of sendmail itself; these might be candidates
< 		  for libc.a.
< 	md	  Some m4 files used to isolate machine dependencies.
< 	src	  The source for the sendmail program itself.
< 	test	  Some files used for testing -- mostly these are
< 		  shell files intended as the targets for aliasing.
< 
< The following are the known major problems and their Problem Report
< number:
< 
< 012, 043	Names of files and programs cannot have upper case letters
< 		in them -- these get mapped to lower case due to the
< 		case mapping feature.
< 178		Because of the different syntaxes used in envelopes versus
< 		headers, we will occasionally allow syntactically incorrect
< 		headers go out.
< 226		Quote interpretation may be incorrect -- this is not well
< 		defined in the protocols.
< 
< Due to my present circumstances, I am unable to provide a formal
< level of support for this system.  However, I will make whatever
< attempt I can to answer a reasonable number of questions.  Since
< the company I am working for is not working in this area, and has
< indulged me tremendously in letting me work on this at all, I regret
< that I am unable to accept phone calls.  I can be contacted as:
< 
< 		OLD			NEW
<     Arpanet:	eric@Berkeley		eric@Berkeley.ARPA
<     UUCP:	ucbvax!eric		eric@ucbvax.UUCP
< 
< Eric Allman
< Britton-Lee, Inc.
< 
< @(#)READ_ME	4.1		7/25/83
---
> Makefile	A Makefile that will do a vanilla install for you.
> aux		Auxiliary programs for sendmail like rmail and binmail.
> cf		Configuration files.
> doc		Documentation.
> src		The source for the sendmail program itself.
Only in sendmail.target: adb
Only in sendmail.target: adm
Common subdirectories: sendmail.target/aux and sendmail/aux
Common subdirectories: sendmail.target/cf and sendmail/cf
Only in sendmail.target: cf.hosttable
Only in sendmail.target: cf.named
Common subdirectories: sendmail.target/doc and sendmail/doc
Only in sendmail: fdopen.patch
Only in sendmail.target: include
Only in sendmail.target: lib
Only in sendmail.target: md
Common subdirectories: sendmail.target/src and sendmail/src
Only in sendmail: support
Only in sendmail.target: test
Only in sendmail.target/aux: 4.1a_daemon.c
diff -r sendmail.target/aux/Makefile sendmail/aux/Makefile
2,3c2,3
< # Generic top-level makefile for simple commands
< # (c) NeXT, Inc.  1987
---
> # Copyright (c) 1988 Regents of the University of California.
> # All rights reserved.
5,33c5,15
< PRODUCTS= mconnect mailstats praliases vacation
< BINDIR=	$(DSTROOT)/usr/ucb
< ETCDIR=	$(DSTROOT)/usr/etc
< DSTDIRS= $(BINDIR) $(ETCDIR)
< 
< CDEFS=	-DNeXT_MOD -D__STRICT_BSD__ -I../include -I../src -DVMUNIX -DNeXT_NFS
< CFLAGS=	-O -fwritable-strings $(CDEFS)
< IFLAGS= -s -m 755
< LIBS=
< 
< HFILES=
< YFILES=
< CFILES= mconnect.c mailstats.c praliases.c vacation.c
< SFILES=
< 
< DERIVED=
< GARBAGE=
< 
< SRCS= $(HFILES) $(YFILES) $(CFILES) $(SFILES)
< OBJS= $(CFILES:.c=.o) $(YFILES:.y=.o) $(SFILES:.s=.o)
< 
< all:	$(PRODUCTS)
< 
< install: DSTROOT $(DSTDIRS) all
< 	install ${IFLAGS} mconnect.NEW $(ETCDIR)/mconnect
< 	install ${IFLAGS} mailstats.NEW $(ETCDIR)/mailstats
< 	install ${IFLAGS} praliases.NEW $(BINDIR)/praliases
< 	install ${IFLAGS} vacation.NEW $(BINDIR)/vacation
< 
---
> # Redistribution and use in source and binary forms are permitted
> # provided that the above copyright notice and this paragraph are
> # duplicated in all such forms and that any documentation,
> # advertising materials, and other materials related to such
> # distribution and use acknowledge that the software was developed
> # by the University of California, Berkeley.  The name of the
> # University may not be used to endorse or promote products derived
> # from this software without specific prior written permission.
> # THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
> # IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
> # WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
35c17
< # Building mconnect
---
> #	@(#)Makefile	5.5 (Berkeley) 9/20/88
37c19,23
< MCONNECT_OBJS= mconnect.o
---
> CFLAGS=	-O -I../src -I../include
> ALL=	mconnect mailstats praliases mail rmail
> SRCS=	mconnect.c mail.c mailstats.c praliases.c rmail.c
> OBJS=	mconnect.o mail.o mailstats.o praliases.o rmail.o
> MAN=	binmail.0 rmail.0
39,40c25
< mconnect.NEW:	${MCONNECT_OBJS} mconnect_vers.o
< 	$(CC) $(CFLAGS) -o $@ ${MCONNECT_OBJS} mconnect_vers.o ${LIBS}
---
> all: ${ALL}
42,44c27,28
< mconnect_vers.c: ${DOVERS} ${MCONNECT_OBJS}
< 	@rm -f $@
< 	vers_string -c mconnect > $@
---
> rmail mconnect mailstats mail:
> 	${CC} ${CFLAGS} -o $@ $@.c
46,49c30,31
< #
< # Building mailstats
< #
< MAILSTATS_OBJS= mailstats.o
---
> praliases:
> 	${CC} ${CFLAGS} -o $@ $@.c -ldbm
51,52c33,34
< mailstats.NEW:	${MAILSTATS_OBJS} mailstats_vers.o
< 	$(CC) $(CFLAGS) -o $@ ${MAILSTATS_OBJS} mailstats_vers.o ${LIBS}
---
> clean:
> 	rm -f core ${ALL} ${OBJS}
54,56c36,37
< mailstats_vers.c: ${DOVERS} ${MAILSTATS_OBJS}
< 	@rm -f $@
< 	vers_string -c mailstats > $@
---
> cleandir: clean
> 	rm -f ${MAN} tags .depend
58,61c39,40
< #
< # Building praliases
< #
< PRALIASES_OBJS= praliases.o
---
> depend: ${SRCS}
> 	mkdep -p ${CFLAGS} ${SRCS}
63,122c42,46
< praliases.NEW:	${PRALIASES_OBJS} praliases_vers.o
< 	$(CC) $(CFLAGS) -o $@ ${PRALIASES_OBJS} praliases_vers.o ${LIBS} -ldbm
< 
< praliases_vers.c: ${DOVERS} ${PRALIASES_OBJS}
< 	@rm -f $@
< 	vers_string -c praliases > $@
< 
< #
< # Building vacation
< #
< VACATION_OBJS= vacation.o convtime.o
< 
< convtime.o: ../src/convtime.c
< 	${CC} ${CFLAGS} -c ../src/convtime.c
< 
< vacation.NEW:	${VACATION_OBJS} vacation_vers.o
< 	$(CC) $(CFLAGS) -o $@ ${VACATION_OBJS} vacation_vers.o ${LIBS} -ldbm
< 
< vacation_vers.c: ${DOVERS} ${VACATION_OBJS}
< 	@rm -f $@
< 	vers_string -c vacation > $@
< 
< 
< #
< # Standard targets
< #
< $(PRODUCTS):	Makedep $$@.NEW
< 
< clean:	ALWAYS
< 	-rm -f *.o *.NEW TAGS tags vers.c Makedep $(PRODUCTS) $(DERIVED) \
< 		$(GARBAGE)
< 
< DSTROOT:
< 	@if [ -n "$($@)" ]; \
< 	then \
< 		exit 0; \
< 	else \
< 		echo Must define $@; \
< 		exit 1; \
< 	fi
< 
< $(DSTDIRS):
< 	mkdirs $@
< 
< depend Makedep: $(DERIVED)
< 	rm -f Makedep
< 	$(CC) -M $(CDEFS) $(CFILES) $(SFILES) $(DERIVED) | \
< 	    awk '{ if ($$1 != prev) { if (rec != "") print rec; \
< 		rec = $$0; prev = $$1; } \
< 		else { if (length(rec $$2) > 78) { print rec; rec = $$0; } \
< 		else rec = rec " " $$2 } } \
< 		END { print rec }' >Makedep
< 
< tags:	ALWAYS
< 	etags $(SRCS)
< 	ctags $(SRCS)
< 
< ALWAYS:
< 
< -include Makedep
---
> install: ${MAN}
> 	install -s -o root -g bin -m 4755 mail ${DESTDIR}/bin/mail
> 	install -s -o bin -g bin -m 755 rmail ${DESTDIR}/bin/rmail
> 	install -s -o bin -g bin -m 755 mconnect mailstats praliases ${DESTDIR}/usr/lib
> 	install -c -o bin -g bin -m 444 ${MAN} ${DESTDIR}/usr/man/cat1
Only in sendmail.target/aux: Makefile.m4
diff -r sendmail.target/aux/arpa.c sendmail/aux/arpa.c
18c18
< static char	SccsId[] = "@(#)arpa.c	5.1 (Berkeley) 6/7/85";
---
> static char	SccsId[] = "@(#)arpa.c	5.2 (Berkeley) 12/28/88";
26c26
< # include	"useful.h"
---
> # include	<useful.h>
28c28
< char Version[] = "@(#)Arpa-mailer version 5.1 of 6/7/85";
---
> char Version[] = "@(#)Arpa-mailer version 5.2 of 12/28/88";
Only in sendmail.target/aux: asm.sed
Only in sendmail/aux: binmail.0
Only in sendmail/aux: binmail.1
Only in sendmail.target/aux: c.ingvax.h
Only in sendmail.target/aux: conf.h.old
Only in sendmail/aux: delivermail.sh
Only in sendmail.target/aux: logger.1
Only in sendmail/aux: mail.c
diff -r sendmail.target/aux/mailstats.c sendmail/aux/mailstats.c
1,6c1,18
< /* @(#)mailstats.c	1.3 87/09/08 3.2/4.3NFSSRC */
< # include <sys/types.h>
< # include <sys/stat.h>
< # include <stdio.h>
< # include "conf.h"
< # include "mailstats.h"
---
> /*
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  *
>  */
9,10c21,24
< static char sccsid[] = "@(#)mailstats.c 1.4 86/07/16 SMI"; /* From UCB 4.1 7/25/83 */
< #endif
---
> char copyright[] =
> "@(#) Copyright (c) 1988 Regents of the University of California.\n\
>  All rights reserved.\n";
> #endif /* not lint */
12,20c26,28
< /*
< **  MAILSTATS -- print mail statistics.
< **
< **	Arguments: 
< **		file		Name of statistics file.
< **
< **	Exit Status:
< **		zero.
< */
---
> #ifndef lint
> static char sccsid[] = "@(#)mailstats.c	5.5 (Berkeley) 6/29/88";
> #endif /* not lint */
21a30,33
> #include <sys/file.h>
> #include <sendmail.h>
> #include <mailstats.h>
> 
23c35,36
< 	char  **argv;
---
> 	int argc;
> 	char **argv;
25,27c38,40
< 	register int fd;
< 	struct statistics st;
< 	char *sfile = "/etc/sendmail/sendmail.st";
---
> 	extern char *optarg;
> 	extern int optind;
> 	struct statistics stat;
29,30c42,43
< 	struct stat sbuf;
< 	extern char *ctime();
---
> 	int ch, fd;
> 	char *sfile, *ctime();
32c45,57
< 	if (argc > 1) sfile = argv[1];
---
> 	sfile = "/usr/lib/sendmail.st";
> 	while ((ch = getopt(argc, argv, "f:")) != EOF)
> 		switch((char)ch) {
> 		case 'f':
> 			sfile = optarg;
> 			break;
> 		case '?':
> 		default:
> 			fputs("usage: mailstats [-f file]\n", stderr);
> 			exit(EX_USAGE);
> 		}
> 	argc -= optind;
> 	argv += optind;
34,36c59,60
< 	fd = open(sfile, 0);
< 	if (fd < 0)
< 	{
---
> 	if ((fd = open(sfile, O_RDONLY)) < 0) {
> 		fputs("mailstats: ", stderr);
38c62
< 		exit(1);
---
> 		exit(EX_NOINPUT);
40,45c64,67
< 	fstat(fd, &sbuf);
< 	if (read(fd, &st, sizeof st) != sizeof st ||
< 	    st.stat_size != sizeof st)
< 	{
< 		(void) sprintf(stderr, "File size change\n");
< 		exit(1);
---
> 	if (read(fd, &stat, sizeof(stat)) != sizeof(stat) ||
> 	    stat.stat_size != sizeof(stat)) {
> 		fputs("mailstats: file size changed.\n", stderr);
> 		exit(EX_OSERR);
48,50c70,71
< 	printf("Mail statistics from %24.24s", ctime(&st.stat_itime));
< 	printf(" to %s\n", ctime(&sbuf.st_mtime));
< 	printf("  Mailer   msgs from  bytes from    msgs to    bytes to\n");
---
> 	printf("Statistics from %s", ctime(&stat.stat_itime));
> 	printf(" M msgsfr bytes_from  msgsto   bytes_to\n");
52,64c73,77
< 	{
< 		if (st.stat_nf[i] == 0 && st.stat_nt[i] == 0)
< 			continue;
< 		printf("%2d %-10s", i, st.stat_names[i]);
< 		if (st.stat_nf[i])
< 		  printf("%6ld %10ldK ", st.stat_nf[i], st.stat_bf[i]);
< 		else
< 		  printf("                   ");
< 		if (st.stat_nt[i])
< 		  printf("%10ld %10ldK\n", st.stat_nt[i], st.stat_bt[i]);
< 		else
< 		  printf("\n");
< 	}
---
> 		if (stat.stat_nf[i] || stat.stat_nt[i])
> 			printf("%2d %6ld %10ldK %6ld %10ldK\n", i,
> 			    stat.stat_nf[i], stat.stat_bf[i],
> 			    stat.stat_nt[i], stat.stat_bt[i]);
> 	exit(0);
Only in sendmail.target/aux: mailstats.c.nonfs
Only in sendmail.target/aux: mailstats_vers.c
diff -r sendmail.target/aux/matchhdr.c sendmail/aux/matchhdr.c
12c12
< static char	SccsId[] = "@(#)matchhdr.c	5.1 (Berkeley) 6/7/85";
---
> static char	SccsId[] = "@(#)matchhdr.c	5.2 (Berkeley) 12/28/88";
17c17
< # include "useful.h"
---
> # include <useful.h>
19c19
< SCCSID(@(#)matchhdr.c	5.1		6/7/85);
---
> SCCSID(@(#)matchhdr.c	5.2		12/28/88);
diff -r sendmail.target/aux/mconnect.c sendmail/aux/mconnect.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
13c21
< "@(#) Copyright (c) 1980 Regents of the University of California.\n\
---
> "@(#) Copyright (c) 1988 Regents of the University of California.\n\
15c23
< #endif not lint
---
> #endif /* not lint */
18,19c26,27
< static char	SccsId[] = "@(#)mconnect.c	5.2 (Berkeley) 7/13/85";
< #endif not lint
---
> static char sccsid[] = "@(#)mconnect.c	5.4 (Berkeley) 6/29/88";
> #endif /* not lint */
21,28c29,36
< # include <stdio.h>
< # include <signal.h>
< # include <ctype.h>
< # include <sgtty.h>
< # include <sys/types.h>
< # include <sys/socket.h>
< # include <netinet/in.h>
< # include <netdb.h>
---
> #include <stdio.h>
> #include <signal.h>
> #include <ctype.h>
> #include <sgtty.h>
> #include <sys/types.h>
> #include <sys/socket.h>
> #include <netinet/in.h>
> #include <netdb.h>
30,31c38
< struct sockaddr_in	SendmailAddress;
< struct sgttyb		TtyBuf;
---
> static struct sgttyb TtyBuf;
36a44,46
> 	extern char *optarg;
> 	extern int optind;
> 	register FILE *f;
38,44d47
< #ifdef	NeXT_NFS
< 	char *host = NULL;
< #else	NeXT_NFS
< 	char *host;
< 	register int i;
< #endif	NeXT_NFS
< 	int pid;
46,58c49,53
< 	int raw = 0;
< 	char buf[1000];
< #ifdef	NeXT_NFS
< 	int on = 1;
< 	register struct hostent *hp;
< 	u_long theaddr;
< #else	NeXT_NFS
< 	register char *p;
< #endif	NeXT_NFS
< 	extern char *index();
< 	register FILE *f;
< 	extern u_long inet_addr();
< 	extern finis();
---
> 	struct sockaddr_in SendmailAddress;
> 	int ch, raw;
> 	char *host, buf[1000], *index();
> 	u_long inet_addr();
> 	int finis();
60,68c55,59
< 	(void) gtty(0, &TtyBuf);
< 	(void) signal(SIGINT, finis);
< #ifdef	NeXT_NFS
< 	s = socket(AF_INET, SOCK_STREAM, 0);
< #else	NeXT_NFS
< 	s = socket(AF_INET, SOCK_STREAM, 0, 0);
< #endif	NeXT_NFS
< 	if (s < 0)
< 	{
---
> 	raw = 0;
> 	(void)gtty(0, &TtyBuf);
> 	(void)signal(SIGINT, finis);
> 
> 	if ((s = socket(AF_INET, SOCK_STREAM, 0, 0)) < 0) {
72,74c63
< #ifdef	NeXT_NFS
< 	(void) setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (char *)&on, sizeof(on));
< #endif	NeXT_NFS
---
> 
79,101c68,84
< 	while (--argc > 0)
< 	{
< 		register char *p = *++argv;
< 
< 		if (*p == '-')
< 		{
< 			switch (*++p)
< 			{
< 			  case 'h':		/* host */
< 				break;
< 
< 			  case 'p':		/* port */
< 				SendmailAddress.sin_port = htons(atoi(*++argv));
< 				argc--;
< 				break;
< 
< 			  case 'r':		/* raw connection */
< 				raw = 1;
< 				TtyBuf.sg_flags &= ~CRMOD;
< 				stty(0, &TtyBuf);
< 				TtyBuf.sg_flags |= CRMOD;
< 				break;
< 			}
---
> 	while ((ch = getopt(argc, argv, "hp:r")) != EOF)
> 		switch((char)ch) {
> 		case 'h':	/* host */
> 			break;
> 		case 'p':	/* port */
> 			SendmailAddress.sin_port = htons(atoi(optarg));
> 			break;
> 		case 'r':	/* raw connection */
> 			raw = 1;
> 			TtyBuf.sg_flags &= ~CRMOD;
> 			stty(0, &TtyBuf);
> 			TtyBuf.sg_flags |= CRMOD;
> 			break;
> 		case '?':
> 		default:
> 			fputs("usage: mconnect [-hr] [-p port] [host]\n", stderr);
> 			exit(-1);
103,107c86,87
< 		else if (host == NULL)
< 			host = p;
< 	}
< 	if (host == NULL)
< 		host = "localhost";
---
> 	argc -= optind;
> 	argv += optind;
109,117c89,90
< #ifdef	NeXT_NFS
< 	hp = gethostbyname(host);
< 	if (hp == NULL)
< 	{
< 		/* Try for dotted pair or whatever */
< 		theaddr = inet_addr(host);
< 		SendmailAddress.sin_addr.s_addr = theaddr;
< 		if (-1 == theaddr) {
< #else	NeXT_NFS
---
> 	host = argc ? *argv : "localhost";
> 
120,121c93
< 	else
< 	{
---
> 	else {
124,126c96
< 		if (hp == NULL)
< 		{
< #endif	NeXT_NFS
---
> 		if (hp == NULL) {
130,132d99
< #ifdef	NeXT_NFS
< 	} else {
< #endif	NeXT_NFS
136,143c103
< #ifdef	NeXT_NFS
< 	printf("connecting to host %s (%s), port %d\r\n", host,
< 	       inet_ntoa(SendmailAddress.sin_addr),
< 	       SendmailAddress.sin_port);
< 	if (connect(s, (struct sockaddr *)&SendmailAddress,
< 	    sizeof SendmailAddress) < 0)
< #else	NeXT_NFS
< 	printf("connecting to host %s (0x%x), port 0x%x\r\n", host,
---
> 	printf("connecting to host %s (0x%lx), port 0x%x\r\n", host,
145,147c105
< 	if (connect(s, &SendmailAddress, sizeof SendmailAddress, 0) < 0)
< #endif	NeXT_NFS
< 	{
---
> 	if (connect(s, &SendmailAddress, sizeof(SendmailAddress), 0) < 0) {
153,156c111,113
< 	printf("connection open\n");
< 	pid = fork();
< 	if (pid < 0)
< 	{
---
> 	puts("connection open");
> 	switch(fork()) {
> 	case -1:
159,162c116
< 	}
< 	if (pid == 0)
< 	{
< 		/* child -- standard input to sendmail */
---
> 	case 0: {		/* child -- standard input to sendmail */
166,167c120
< 		while ((c = fgetc(stdin)) >= 0)
< 		{
---
> 		while ((c = fgetc(stdin)) >= 0) {
172c125
< 				fflush(f);
---
> 				(void)fflush(f);
174,177d126
< #ifdef	NeXT_NFS
< 		shutdown(s,1);
< 		sleep(10);
< #endif	NeXT_NFS
179,181c128
< 	else
< 	{
< 		/* parent -- sendmail to standard output */
---
> 	default:		/* parent -- sendmail to standard output */
183,184c130
< 		while (fgets(buf, sizeof buf, f) != NULL)
< 		{
---
> 		while (fgets(buf, sizeof(buf), f) != NULL) {
186c132
< 			fflush(stdout);
---
> 			(void)fflush(stdout);
Only in sendmail.target/aux: mconnect_vers.c
diff -r sendmail.target/aux/newaliases.c sendmail/aux/newaliases.c
58c58
< 	char *cffile = "/etc/sendmail/sendmail.cf";
---
> 	char *cffile = "/usr/lib/sendmail.cf";
Only in sendmail.target/aux: newsyslog
diff -r sendmail.target/aux/praliases.c sendmail/aux/praliases.c
1c1,17
< # include "sendmail.h"
---
> /*
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
3c19,23
< static	char sccsid[] = "%W%	%G%";
---
> #ifndef lint
> char copyright[] =
> "@(#) Copyright (c) 1988 Regents of the University of California.\n\
>  All rights reserved.\n";
> #endif /* not lint */
5,7c25,27
< typedef struct { char *dptr; int dsize; } datum;
< datum	firstkey(), nextkey(), fetch();
< char	*filename = "/etc/sendmail/aliases";
---
> #ifndef lint
> static char sccsid[] = "@(#)praliases.c	5.4 (Berkeley) 6/29/88";
> #endif /* not lint */
8a29,36
> #include <sendmail.h>
> 
> typedef struct {
> 	char *dptr;
> 	int dsize;
> } datum;
> 
> 
12c40,44
< 	datum content, key;
---
> 	extern char *optarg;
> 	extern int optind;
> 	static char *filename = "/usr/lib/aliases";
> 	datum content, key, firstkey(), nextkey(), fetch();
> 	int ch;
14,19c46,57
< 	if (argc > 2 && strcmp(argv[1], "-f") == 0)
< 	{
< 		argv++;
< 		filename = *++argv;
< 		argc -= 2;
< 	}
---
> 	while ((ch = getopt(argc, argv, "f:")) != EOF)
> 		switch((char)ch) {
> 		case 'f':
> 			filename = optarg;
> 			break;
> 		case '?':
> 		default:
> 			fputs("usage: praliases [-f file]\n", stderr);
> 			exit(EX_USAGE);
> 		}
> 	argc -= optind;
> 	argv += optind;
23,24c61
< 	argc--, argv++;
< 	if (argc == 0) {
---
> 	if (!argc)
27c64
< 			printf("\n%s:%s\n", key.dptr, content.dptr);
---
> 			printf("%s:%s\n", key.dptr, content.dptr);
29,31c66
< 		exit(EX_OK);
< 	}
< 	while (argc) {
---
> 	else for (; *argv; ++argv) {
33c68
< 		key.dsize = strlen(*argv)+1;
---
> 		key.dsize = strlen(*argv) + 1;
35,36c70,71
< 		if (content.dptr == 0)
< 			printf("%s: No such key\n");
---
> 		if (!content.dptr)
> 			printf("%s: No such key\n", key.dptr);
38,39c73
< 			printf("\n%s:%s\n", key.dptr, content.dptr);
< 		argc--, argv++;
---
> 			printf("%s:%s\n", key.dptr, content.dptr);
Only in sendmail.target/aux: praliases_vers.c
Only in sendmail.target/aux: rmail
Only in sendmail/aux: rmail.0
Only in sendmail/aux: rmail.1
diff -r sendmail.target/aux/rmail.c sendmail/aux/rmail.c
2,9c2,16
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1981, 1988 The Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
13c20
< "@(#) Copyright (c) 1980 Regents of the University of California.\n\
---
> "@(#) Copyright (c) 1981, 1988 The Regents of the University of California.\n\
15c22
< #endif not lint
---
> #endif /* not lint */
18,19c25,26
< static char	SccsId[] = "@(#)rmail.c	5.1 (Berkeley) 6/7/85";
< #endif not lint
---
> static char sccsid[] = "@(#)rmail.c	4.12 (Berkeley) 1/19/89";
> #endif /* not lint */
22,28c29,34
< **  RMAIL -- UUCP mail server.
< **
< **	This program reads the >From ... remote from ... lines that
< **	UUCP is so fond of and turns them into something reasonable.
< **	It calls sendmail giving it a -f option built from these
< **	lines.
< */
---
>  * RMAIL -- UUCP mail server.
>  *
>  *	This program reads the >From ... remote from ... lines that
>  *	UUCP is so fond of and turns them into something reasonable.
>  *	It calls sendmail giving it a -f option built from these lines. 
>  */
30,31c36,40
< # include <stdio.h>
< # include <sysexits.h>
---
> #include <stdio.h>
> #include <sysexits.h>
> #include <sys/types.h>
> #include <sys/file.h>
> #include <sys/stat.h>
33c42
< typedef char	bool;
---
> typedef char bool;
37,39c46,47
< extern FILE	*popen();
< extern char	*index();
< extern char	*rindex();
---
> extern char *index();
> extern char *rindex();
41c49
< bool	Debug;
---
> char *Domain = "UUCP";		/* Default "Domain" */
43c51
< # define MAILER	"/usr/lib/sendmail"
---
> #define MAILER	"/usr/lib/sendmail"
45a54
> 	int argc;
48,54c57,63
< 	FILE *out;	/* output to sendmail */
< 	char lbuf[512];	/* one line of the message */
< 	char from[512];	/* accumulated path of sender */
< 	char ufrom[64];	/* user on remote system */
< 	char sys[64];	/* a system in path */
< 	char junk[512];	/* scratchpad */
< 	char cmd[2000];
---
> 	char lbuf[1024];	/* one line of the message */
> 	char from[512];		/* accumulated path of sender */
> 	char ufrom[512];	/* user on remote system */
> 	char sys[512];		/* a system in path */
> 	char fsys[512];		/* first system in path */
> 	char junk[1024];	/* scratchpad */
> 	char *args[100];	/* arguments to mailer command */
56c65
< 	register char *uf;	/* ptr into ufrom */
---
> 	register char *uf = NULL;	/* ptr into ufrom */
57a67,70
> 	long position;
> 	struct stat sbuf;
> #ifdef DEBUG
> 	bool Debug;
59,61c72
< # ifdef DEBUG
< 	if (argc > 1 && strcmp(argv[1], "-T") == 0)
< 	{
---
> 	if (argc > 1 && strcmp(argv[1], "-T") == 0) {
66c77
< # endif DEBUG
---
> #endif
68,69c79
< 	if (argc < 2)
< 	{
---
> 	if (argc < 2) {
73,74c83,89
< 
< 	(void) strcpy(from, "");
---
> 	if (argc > 2 && strncmp(argv[1], "-D", 2) == 0) {
> 		Domain = &argv[1][2];
> 		argc -= 2;
> 		argv += 2;
> 	}
> 	from[0] = '\0';
> 	fsys[0] = '\0';
77,78c92
< 	for (;;)
< 	{
---
> 	for (position = 0;; position = ftell(stdin)) {
80c94,95
< 		if (strncmp(lbuf, "From ", 5) != 0 && strncmp(lbuf, ">From ", 6) != 0)
---
> 		if (strncmp(lbuf, "From ", 5) != 0 &&
> 		    strncmp(lbuf, ">From ", 6) != 0)
85,89c100,102
< 		for (;;)
< 		{
< 			cp = index(cp+1, 'r');
< 			if (cp == NULL)
< 			{
---
> 		for (;;) {
> 			cp = index(cp + 1, 'r');
> 			if (cp == NULL) {
92,93c105
< 				if (p != NULL)
< 				{
---
> 				if (p != NULL) {
99c111,112
< 				cp = "remote from somewhere";
---
> 				(void) strcpy(sys, "");
> 				break;	/* no "remote from" found */
105c118
< 			if (strncmp(cp, "remote from ", 12)==0)
---
> 			if (strncmp(cp, "remote from ", 12) == 0)
110,111c123,128
< 		(void) strcat(from, sys);
< 		(void) strcat(from, "!");
---
> 		if (fsys[0] == '\0')
> 			(void) strcpy(fsys, sys);
> 		if (sys[0]) {
> 			(void) strcat(from, sys);
> 			(void) strcat(from, "!");
> 		}
116a134,137
> 	if (uf == NULL) {	/* No From line was provided */
> 		fprintf(stderr, "No From line in rmail\n");
> 		exit(EX_DATAERR);
> 	}
117a139,140
> 	(void) fstat(0, &sbuf);
> 	(void) lseek(0, position, L_SET);
119,127c142,160
< 	(void) sprintf(cmd, "%s -ee -f%s", MAILER, from);
< 	while (*++argv != NULL)
< 	{
< 		(void) strcat(cmd, " '");
< 		if (**argv == '(')
< 			(void) strncat(cmd, *argv + 1, strlen(*argv) - 2);
< 		else
< 			(void) strcat(cmd, *argv);
< 		(void) strcat(cmd, "'");
---
> 	/*
> 	 * Now we rebuild the argument list and chain to sendmail. Note that
> 	 * the above lseek might fail on irregular files, but we check for
> 	 * that case below. 
> 	 */
> 	i = 0;
> 	args[i++] = MAILER;
> 	args[i++] = "-oee";		/* no errors, just status */
> 	args[i++] = "-odq";		/* queue it, don't try to deliver */
> 	args[i++] = "-oi";		/* ignore '.' on a line by itself */
> 	if (fsys[0] != '\0') {		/* set sender's host name */
> 		static char junk2[512];
> 
> 		if (index(fsys, '.') == NULL) {
> 			(void) strcat(fsys, ".");
> 			(void) strcat(fsys, Domain);
> 		}
> 		(void) sprintf(junk2, "-oMs%s", fsys);
> 		args[i++] = junk2;
128a162,181
> 					/* set protocol used */
> 	(void) sprintf(junk, "-oMr%s", Domain);
> 	args[i++] = junk;
> 	if (from[0] != '\0') {		/* set name of ``from'' person */
> 		static char junk2[512];
> 
> 		(void) sprintf(junk2, "-f%s", from);
> 		args[i++] = junk2;
> 	}
> 	for (; *++argv != NULL; i++) {
> 		/*
> 		 * don't copy arguments beginning with - as they will
> 		 * be passed to sendmail and could be interpreted as flags
> 		 * should be fixed in sendmail by using getopt(3), and
> 		 * just passing "--" before regular args.
> 		 */
> 		if (**argv != '-')
> 			args[i] = *argv;
> 	}
> 	args[i] = NULL;
130,141c183,187
< 	if (Debug)
< 		printf("cmd='%s'\n", cmd);
< #endif
< 	out = popen(cmd, "w");
< 	fputs(lbuf, out);
< 	while (fgets(lbuf, sizeof lbuf, stdin))
< 		fputs(lbuf, out);
< 	i = pclose(out);
< 	if ((i & 0377) != 0)
< 	{
< 		fprintf(stderr, "pclose: status 0%o\n", i);
< 		exit(EX_OSERR);
---
> 	if (Debug) {
> 		printf("Command:");
> 		for (i = 0; args[i]; i++)
> 			printf(" %s", args[i]);
> 		printf("\n");
142a189,207
> #endif
> 	if ((sbuf.st_mode & S_IFMT) != S_IFREG) {
> 		/*
> 		 * If we were not called with standard input on a regular
> 		 * file, then we have to fork another process to send the
> 		 * first line down the pipe. 
> 		 */
> 		int pipefd[2];
> #ifdef DEBUG
> 		if (Debug)
> 			printf("Not a regular file!\n");
> #endif
> 		if (pipe(pipefd) < 0)
> 			exit(EX_OSERR);
> 		if (fork() == 0) {
> 			/*
> 			 * Child: send the message down the pipe. 
> 			 */
> 			FILE *out;
144c209,225
< 	exit((i >> 8) & 0377);
---
> 			out = fdopen(pipefd[1], "w");
> 			close(pipefd[0]);
> 			fputs(lbuf, out);
> 			while (fgets(lbuf, sizeof lbuf, stdin))
> 				fputs(lbuf, out);
> 			(void) fclose(out);
> 			exit(EX_OK);
> 		}
> 		/*
> 		 * Parent: call sendmail with pipe as standard input 
> 		 */
> 		close(pipefd[1]);
> 		dup2(pipefd[0], 0);
> 	}
> 	execv(MAILER, args);
> 	fprintf(stderr, "Exec of %s failed!\n", MAILER);
> 	exit(EX_OSERR);
Only in sendmail.target/aux: showdbm.c
Only in sendmail.target/aux: uname.c
Only in sendmail.target/aux: vacation.1
Only in sendmail.target/aux: vacation.c
Only in sendmail.target/aux: vacation_vers.c
Only in sendmail/cf: KEY
Only in sendmail/cf: M4_KEY
Only in sendmail.target/cf: Makefile
Only in sendmail/cf: README
Only in sendmail.target/cf: SCCS_NOTES
Only in sendmail.target/cf: base.m4
Only in sendmail/cf: cf
Only in sendmail.target/cf: compat.m4
Only in sendmail.target/cf: ddnm.m4
Only in sendmail.target/cf: ether.m4
Only in sendmail.target/cf: etherm.m4
Only in sendmail.target/cf: localm.m4
Only in sendmail/cf: m4
Only in sendmail.target/cf: main.mc
Only in sendmail.target/cf: nextbase.m4
Only in sendmail/cf: sitedep
Only in sendmail.target/cf: subsidiary.mc
Only in sendmail.target/cf: suucpm.m4
Only in sendmail.target/cf: uucpm.m4
Only in sendmail.target/cf: version.m4
Only in sendmail.target/cf: zerobase.m4
Only in sendmail.target/doc: .places
Only in sendmail/doc: 07.sendmailop
Only in sendmail/doc: 16.sendmail
Only in sendmail.target/doc: Makedep
Only in sendmail.target/doc: Makefile
Only in sendmail.target/doc: abstract
Only in sendmail.target/doc: diagram
Only in sendmail.target/doc: mailaddr.7
Only in sendmail.target/doc: sendmail.8
Only in sendmail.target/doc: usenix
Only in sendmail/doc: usenix.abs
Only in sendmail.target/src: .list
Only in sendmail.target/src: .places
Only in sendmail.target/src: CHANGES
Only in sendmail.target/src: FILES
diff -r sendmail.target/src/Makefile sendmail/src/Makefile
2,3c2,3
< # Generic top-level makefile for simple commands
< # (c) NeXT, Inc.  1987
---
> # Copyright (c) 1988 Regents of the University of California.
> # All rights reserved.
5,8c5,27
< PRODUCT= sendmail
< BINDIR= $(DSTROOT)/usr/bin
< LIBDIR=	$(DSTROOT)/usr/lib
< DSTDIRS= $(LIBDIR)
---
> # Redistribution and use in source and binary forms are permitted
> # provided that the above copyright notice and this paragraph are
> # duplicated in all such forms and that any documentation,
> # advertising materials, and other materials related to such
> # distribution and use acknowledge that the software was developed
> # by the University of California, Berkeley.  The name of the
> # University may not be used to endorse or promote products derived
> # from this software without specific prior written permission.
> # THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
> # IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
> # WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
> #
> #	@(#)Makefile	5.11 (Berkeley) 1/3/89
> #
> SRCS=	alias.c arpadate.c clock.c collect.c conf.c convtime.c daemon.c \
> 	deliver.c domain.c envelope.c err.c headers.c macro.c main.c \
> 	parseaddr.c queue.c readcf.c recipient.c savemail.c srvrsmtp.c \
> 	stab.c stats.c sysexits.c trace.c usersmtp.c util.c Version.c
> OBJS=	alias.o arpadate.o clock.o collect.o conf.o convtime.o daemon.o \
> 	deliver.o domain.o envelope.o err.o headers.o macro.o main.o \
> 	parseaddr.o queue.o readcf.o recipient.o savemail.o srvrsmtp.o \
> 	stab.o stats.o sysexits.o trace.o usersmtp.o util.o
> MAN=	sendmail.0 newaliases.0 aliases.0
10,14c29
< CDEFS=	-DNeXT_MOD -D__STRICT_BSD__ -I../include -I/usr/include/arpa \
< 	-DVMUNIX -DMXDOMAIN -DYELLOWPAGES
< CFLAGS=	-O -fwritable-strings $(CDEFS)
< IFLAGS= -s -c -o root -m 4551
< LIBS= -ldbm
---
> CFLAGS=	-O -I. -I../include -DVMUNIX
16,23c31,34
< HFILES= conf.h sendmail.h dbm.h mailstats.h trace.h
< YFILES=
< CFILES= conf.c deliver.c main.c parseaddr.c err.c alias.c savemail.c \
< 	sysexits.c util.c bmove.c arpadate.c version.c collect.c \
< 	macro.c headers.c readcf.c stab.c recipient.c stats.c daemon.c \
< 	usersmtp.c srvrsmtp.c queue.c clock.c trace.c envelope.c \
< 	convtime.c remote.c domain.c
< SFILES=
---
> GET=	sccs get
> DELTA=	sccs delta
> WHAT=	what
> PRT=	sccs prt
25,26c36,38
< DERIVED=
< GARBAGE=
---
> sendmail: ${OBJS} Version.o
> 	${CC} ${COPTS} -o $@ Version.o ${OBJS} -ldbm
> 	size sendmail; ls -l sendmail; ${WHAT} < Version.o
28,29c40,42
< SRCS= $(HFILES) $(YFILES) $(CFILES) $(SFILES)
< OBJS= $(CFILES:.c=.o) $(YFILES:.y=.o) $(SFILES:.s=.o)
---
> dsendmail: ${OBJS} Version.o
> 	${CC} ${COPTS} -o sendmail Version.o ${OBJS} -ldbm -lresolv
> 	size sendmail; ls -l sendmail; ${WHAT} < Version.o
31c44,59
< all:	$(PRODUCT)
---
> install: ${MAN}
> 	install -c -s -o root -g kmem -m 6755 sendmail ${DESTDIR}/usr/lib
> 	install -c -o bin -g bin -m 644 /dev/null ${DESTDIR}/usr/lib/sendmail.fc
> 	install -c -o bin -g bin -m 666 /dev/null ${DESTDIR}/usr/lib/sendmail.st
> 	install -c -o bin -g bin -m 666 /dev/null ${DESTDIR}/usr/lib/sendmail.st
> 	install -c -o bin -g bin -m 444 sendmail.hf /usr/lib/sendmail.hf
> 	install -c -o bin -g bin -m 444 sendmail.0 ${DESTDIR}/usr/man/cat8
> 	install -c -o bin -g bin -m 444 aliases.0 ${DESTDIR}/usr/man/cat5
> 	install -c -o bin -g bin -m 444 newaliases.0 ${DESTDIR}/usr/man/cat1
> 	-mkdir ${DESTDIR}/usr/spool/mqueue
> 	chown root.wheel ${DESTDIR}/usr/spool/mqueue
> 	chmod 775 ${DESTDIR}/usr/spool/mqueue
> 	rm -f ${DESTDIR}/usr/ucb/newaliases
> 	ln -s ${DESTDIR}/usr/lib/sendmail ${DESTDIR}/usr/ucb/newaliases
> 	rm -f ${DESTDIR}/usr/ucb/mailq
> 	ln -s ${DESTDIR}/usr/lib/sendmail ${DESTDIR}/usr/ucb/mailq
33,34c61
< install: DSTROOT $(DSTDIRS) all symlinks
< 	install $(IFLAGS) -l $(BINDIR)/newaliases -l $(BINDIR)/mailq $(PRODUCT).NEW $(LIBDIR)/$(PRODUCT)
---
> version: newversion ${OBJS} Version.c
36,46c63,67
< symlinks:
< 	@if [ ! -h ${DSTROOT}/etc ] ; \
< 	then \
< 		echo "ln -s private/etc ${DSTROOT}/etc" ; \
< 		ln -s private/etc ${DSTROOT}/etc ; \
< 	fi
< 	@if [ ! -h ${DSTROOT}/usr/spool ] ; \
< 	then \
< 		echo "ln -s ../private/spool ${DSTROOT}/usr/spool" ; \
< 		ln -s ../private/spool ${DSTROOT}/usr/spool ; \
< 	fi
---
> newversion:
> 	@rm -f SCCS/p.version.c version.c
> 	@${GET} -e SCCS/s.version.c
> 	@${DELTA} -s SCCS/s.version.c
> 	@${GET} -t -s SCCS/s.version.c
48,50c69,81
< #
< # Building PRODUCT
< #
---
> Version.c: version.c
> 	@echo generating Version.c from version.c
> 	@cp version.c Version.c
> 	@chmod 644 Version.c
> 	@echo "" >> Version.c
> 	@echo "# ifdef COMMENT" >> Version.c
> 	@${PRT} SCCS/s.version.c >> Version.c
> 	@echo "" >> Version.c
> 	@echo "code versions:" >> Version.c
> 	@echo "" >> Version.c
> 	@${WHAT} ${OBJS} >> Version.c
> 	@echo "" >> Version.c
> 	@echo "# endif COMMENT" >> Version.c
52,53c83,84
< $(PRODUCT).NEW:	$(OBJS) vers.o
< 	$(CC) $(CFLAGS) -o $@ $(OBJS) vers.o $(LIBS)
---
> clean: ${SRCS}
> 	rm -f ${OBJS} core sendmail a.out Version.o
55,57c86,87
< vers.c: $(DOVERS) $(OBJS)
< 	@rm -f $@
< 	vers_string -c $(PRODUCT) > $@
---
> cleandir: clean
> 	rm -f ${MAN} tags .depend
59,62c89,90
< #
< # Standard targets
< #
< $(PRODUCT):	Makedep $$@.NEW
---
> depend: ${SRCS}
> 	mkdep ${CFLAGS} ${SRCS}
64,66c92,93
< clean:	ALWAYS
< 	-rm -f *.o *.NEW TAGS tags vers.c Makedep $(PRODUCT) $(DERIVED) \
< 		$(GARBAGE)
---
> tags: ${SRCS}
> 	ctags ${SRCS}
68,95c95,96
< DSTROOT:
< 	@if [ -n "$($@)" ]; \
< 	then \
< 		exit 0; \
< 	else \
< 		echo Must define $@; \
< 		exit 1; \
< 	fi
< 
< $(DSTDIRS):
< 	mkdirs $@
< 
< depend Makedep: $(DERIVED)
< 	rm -f Makedep
< 	$(CC) -M $(CDEFS) $(CFILES) $(SFILES) $(DERIVED) | \
< 	    awk '{ if ($$1 != prev) { if (rec != "") print rec; \
< 		rec = $$0; prev = $$1; } \
< 		else { if (length(rec $$2) > 78) { print rec; rec = $$0; } \
< 		else rec = rec " " $$2 } } \
< 		END { print rec }' >Makedep
< 
< tags:	ALWAYS
< 	etags $(SRCS)
< 	ctags $(SRCS)
< 
< ALWAYS:
< 
< -include Makedep
---
> lint: ${SRCS}
> 	lint -chapbx ${CCONFIG} ${SRCS}
Only in sendmail.target/src: Makefile.m4
Only in sendmail.target/src: Makefile.ns
Only in sendmail.target/src: Makefile.save
diff -r sendmail.target/src/READ_ME sendmail/src/READ_ME
2,4c2,4
< #  Sendmail
< #  Copyright (c) 1983  Eric P. Allman
< #  Berkeley, California
---
> # Copyright (c) 1983 Eric P. Allman
> # Copyright (c) 1988 Regents of the University of California.
> # All rights reserved.
6,8c6,16
< #  Copyright (c) 1983 Regents of the University of California.
< #  All rights reserved.  The Berkeley software License Agreement
< #  specifies the terms and conditions for redistribution.
---
> # Redistribution and use in source and binary forms are permitted
> # provided that the above copyright notice and this paragraph are
> # duplicated in all such forms and that any documentation,
> # advertising materials, and other materials related to such
> # distribution and use acknowledge that the software was developed
> # by the University of California, Berkeley.  The name of the
> # University may not be used to endorse or promote products derived
> # from this software without specific prior written permission.
> # THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
> # IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
> # WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
10c18
< #	@(#)READ_ME	4.2 (Berkeley) 6/7/85
---
> #	@(#)READ_ME	4.5 (Berkeley) 7/10/88
30,33d37
< bmove.c		A core-to-core move.  This is in a separate file
< 		because it can easily be replaced by a blindingly
< 		efficient version on Vaxes.
< bmove.*.s	Versions of bmove optimized for specific processors.
77c81
< (Version 4.2, last update 6/7/85 21:34:51)
---
> (Version 4.5, last update 7/10/88 12:43:25)
diff -r sendmail.target/src/TODO sendmail/src/TODO
2a3,13
> -- get rid of MAXMAILERS, just allocate them as you go; merge the stats
> 	structure in with the MAILERS structure; change the longs in
> 	said structure into u_longs; print the file in ASCII, lock the
> 	file before reading/printing.
> 
> -- clean up sysexits; get rid of EX_BASE, most of sysexits.c is duplicated
> 	in deliver.c
> 
> -- mailq; split it out, by default, just # of messages, also add sort
> 	by machine?
> 
diff -r sendmail.target/src/Version.c sendmail/src/Version.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)version.c	5.51 (Berkeley) 5/2/86";
< #endif not lint
---
> static char sccsid[] = "@(#)version.c	5.61 (Berkeley) 9/20/88";
> #endif /* not lint */
15c23
< char	Version[] = "5.51";
---
> char	Version[] = "5.61";
20a29,65
> D 5.61	88/09/20 22:15:19	eric	484	483	00000/00000/00023
> add I option to insist on Internet domain server; add NAMED_BIND
> compile option to compile in named routines.
> 
> D 5.60	88/06/30 15:00:04	bostic	483	482	00011/00009/00012
> install approved copyright notice
> 
> D 5.59	88/03/13 19:53:40	bostic	482	481	00016/00010/00005
> add Berkeley specific header
> 
> D 5.58	87/02/03 20:44:04	eric	481	479	00000/00000/00015
> pass sending hostname correctly back via the $s macro (broken sometime
> earlier); hack around some name server changes
> 
> D 5.57.1.1	86/12/17 16:08:34	eric	480	479	00000/00000/00015
> hack around compiler bug that gets confused on isascii
> 
> D 5.57	86/10/23 10:11:10	eric	479	478	00000/00000/00015
> Fix security bug allowing writing to arbitrary files; from Bart Miller
> at U. Wisconsin.
> 
> D 5.56	86/10/14 18:06:05	eric	478	477	00000/00000/00015
> don't let "locked job" messages remove transcript & lock
> 
> D 5.55	86/10/14 17:21:15	eric	477	476	00000/00000/00015
> make sure that 0, 1, and 2 are open to avoid confusing syslog;
> from Steve Schoch <schoch@orion.arpa>
> 
> D 5.54	86/07/21 12:21:11	bloom	476	475	00000/00000/00015
> add MX support
> 
> D 5.53	86/06/30 16:20:56	bloom	475	474	00000/00000/00015
> try multiple addresses in SMTP connect
> 
> D 5.52	86/05/06 18:04:16	bloom	474	473	00000/00000/00015
> Fix problem with not closing sockets upon errors when opening connections
> 
2044,2095c2089,2142
< conf.o
< 	conf.c	5.14 (Berkeley) 1/10/86
< main.o
< 	 Copyright (c) 1980 Regents of the University of California.
< 	main.c	5.11 (Berkeley) 1/30/86
< 	sendmail.h	5.8		1/10/86
< collect.o
< 	collect.c	5.2 (Berkeley) 6/8/85
< parseaddr.o
< 	parseaddr.c	5.6 (Berkeley) 4/2/86
< alias.o
< 	alias.c	5.13 (Berkeley) 4/17/86	(with DBM)
< deliver.o
< 	deliver.c	5.10 (Berkeley) 3/2/86
< savemail.o
< 	savemail.c	5.7 (Berkeley) 12/7/85
< err.o
< 	err.c	5.7 (Berkeley) 11/22/85
< readcf.o
< 	readcf.c	5.10 (Berkeley) 1/11/86
< stab.o
< 	stab.c	5.2 (Berkeley) 6/7/85
< headers.o
< 	headers.c	5.7 (Berkeley) 9/21/85
< recipient.o
< 	recipient.c	5.7 (Berkeley) 1/9/86
< stats.o
< 	stats.c	5.8 (Berkeley) 5/2/86
< daemon.o
< 	daemon.c	5.18 (Berkeley) 4/2/86 (with daemon mode)
< usersmtp.o
< 	usersmtp.c	5.7 (Berkeley) 4/2/86
< srvrsmtp.o
< 	srvrsmtp.c	5.18 (Berkeley) 1/5/86
< queue.o
< 	queue.c	5.21 (Berkeley) 4/17/86
< macro.o
< 	macro.c	5.3 (Berkeley) 9/19/85
< util.o
< 	util.c	5.8 (Berkeley) 12/17/85
< clock.o
< 	clock.c	5.4 (Berkeley) 12/17/85
< trace.o
< 	trace.c	5.2 (Berkeley) 6/7/85
< envelope.o
< 	envelope.c	5.12 (Berkeley) 12/17/85
< sysexits.o
< 	sysexits.c	5.2 (Berkeley) 6/7/85
< arpadate.o
< 	arpadate.c	5.4 (Berkeley) 1/9/86
< convtime.o
< 	convtime.c	5.1 (Berkeley) 6/7/85
---
> alias.o:
> 	alias.c	5.16 (Berkeley) 7/14/88 (without DBM)
> arpadate.o:
> 	arpadate.c	5.9 (Berkeley) 6/30/88
> clock.o:
> 	clock.c	5.6 (Berkeley) 6/30/88
> collect.o:
> 	collect.c	5.4 (Berkeley) 6/30/88
> conf.o:
> 	conf.c	5.17 (Berkeley) 6/30/88
> convtime.o:
> 	convtime.c	5.3 (Berkeley) 6/30/88
> daemon.o:
> 	daemon.c	5.27 (Berkeley) 9/20/88 (with daemon mode)
> deliver.o:
> 	deliver.c	5.23 (Berkeley) 9/20/88
> domain.o:
> 	domain.c	5.16 (Berkeley) 9/20/88 (with name server)
> envelope.o:
> 	envelope.c	5.15 (Berkeley) 6/30/88
> err.o:
> 	err.c	5.9 (Berkeley) 6/30/88
> headers.o:
> 	headers.c	5.10 (Berkeley) 6/30/88
> macro.o:
> 	macro.c	5.5 (Berkeley) 6/30/88
> main.o:
> 	 Copyright (c) 1988 Regents of the University of California.
> 	main.c	5.21 (Berkeley) 9/20/88
> 	sendmail.h	5.13		9/20/88
> parseaddr.o:
> 	parseaddr.c	5.9 (Berkeley) 6/30/88
> queue.o:
> 	queue.c	5.24 (Berkeley) 6/30/88 (with queueing)
> readcf.o:
> 	readcf.c	5.14 (Berkeley) 9/20/88
> recipient.o:
> 	recipient.c	5.12 (Berkeley) 6/30/88
> savemail.o:
> 	savemail.c	5.9 (Berkeley) 6/30/88
> srvrsmtp.o:
> 	srvrsmtp.c	5.22 (Berkeley) 6/30/88 (with SMTP)
> stab.o:
> 	stab.c	5.5 (Berkeley) 6/30/88
> stats.o:
> 	stats.c	5.10 (Berkeley) 6/30/88
> sysexits.o:
> 	sysexits.c	5.5 (Berkeley) 6/30/88
> trace.o:
> 	trace.c	5.5 (Berkeley) 6/30/88
> usersmtp.o:
> 	usersmtp.c	5.10 (Berkeley) 6/30/88 (with SMTP)
> util.o:
> 	util.c	5.9 (Berkeley) 12/17/86
diff -r sendmail.target/src/alias.c sendmail/src/alias.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
10a19,26
> #ifndef lint
> #ifdef DBM
> static char sccsid[] = "@(#)alias.c	5.17 (Berkeley) 1/1/89 (with DBM)";
> #else
> static char sccsid[] = "@(#)alias.c	5.17 (Berkeley) 1/1/89 (without DBM)";
> #endif
> #endif /* not lint */
> 
17d32
< # ifdef FLOCK
19d33
< # endif FLOCK
21,31d34
< #ifndef lint
< # ifdef DBM
< static char	SccsId[] = "@(#)alias.c	5.13 (Berkeley) 4/17/86	(with DBM)";
< # else DBM
< static char	SccsId[] = "@(#)alias.c	5.13 (Berkeley) 4/17/86	(without DBM)";
< # endif DBM
< #endif not lint
< 
< static readaliases();
< 
< 
74,76d76
< #ifdef	YELLOWPAGES
< 	extern char *aliaslookup(), *yellowlookup();
< #else	YELLOWPAGES
78d77
< #endif	YELLOWPAGES
80d78
< # ifdef DEBUG
83d80
< # endif
99d95
< #ifdef	YELLOWPAGES
101,103d96
< 		p = yellowlookup(a);
< #endif	YELLOWPAGES
< 	if (p == NULL)
111d103
< # ifdef DEBUG
115d106
< # endif
159,339d149
< #ifdef	YELLOWPAGES
< 
< char *ypDomain = NULL;
< 
< /*
< **  YELLOWMATCH -- look up any token in the Yellow Pages.
< **
< **	Parameters:
< **		string - string to look up
< **		mac - macro to use as name of map
< **
< **	Returns:
< **		True if the value was found in the database
< **
< **	Side Effects:
< **		If token is found, enter into cache.
< **
< **	Warnings:
< **		Will hang forever if no yellow pages server responds
< */
< 
< yellowmatch(string,mac)
<     char *string;
<     char mac;
<   {
<   	int insize, outsize;
< 	register STAB *s;
< 	char *mapname, *result, *macvalue();
< 
< 	if (mac == 'y')
< 	  {
< 	    /*
< 	     * handle the special host name mapping macro.
< 	     */
< 	     struct hostinfo *h, *lookuphost();
< 
< 	     h = lookuphost(string);
< 	     errno = 0;
< 	     return(h->h_exists);
< 	  }
< 	mapname = macvalue(mac,CurEnv);
< 	if (mapname==NULL) return(FALSE);
< 	s = stab(string, ST_CLASS, ST_FIND);
< 	if (s != NULL && bitnset(mac, s->s_class))
< 		return(TRUE);
< 
< 	insize = strlen(string);
< 	if (ypDomain==NULL)
< 		{
< 		  yp_get_default_domain(&ypDomain);
< 		  if (ypDomain==NULL) return(FALSE);
< # ifdef DEBUG
< 		  if (tTd(27, 1))
< 	    printf("Yellow pages domain is %s\n",ypDomain);
< # endif DEBUG
< 		}
< 	if (yp_match(ypDomain,mapname,string, insize, &result, &outsize)
< 	 && yp_match(ypDomain,mapname,string, insize+1, &result, &outsize))
< 	  {
< 	  	errno = 0;
< 		return(FALSE);
< 	  }
< # ifdef DEBUG
< 	if (tTd(27, 1))
< 	    printf("Yellow pages found %s as value for %s\n",result,string);
< # endif DEBUG
< 	s = stab(string, ST_CLASS, ST_ENTER);
< 	setbitn(mac, s->s_class);
< 	free(result);
< 	return(TRUE);
<   }
< 
< /*
< ** MAPUSERNAME -- look up a string in the Yellow Pages with replacement
< **
< **	Parameters:
< **		map -- name of the yp map to use
< **		buf -- input buffer
< **		bufsize -- size of input buffer
< **
< **	Side Effects:
< **		changes buffer to be its value in the map
< */
< mapusername(map, buf, bufsize)
<     char *map, *buf;
<     int bufsize;
<   {
<   	int insize, outsize;
< 	char *result;
< 
< 	if (ypDomain==NULL)
< 		{
< 		  yp_get_default_domain(&ypDomain);
< 		  if (ypDomain==NULL) return;
< 		}
< 	insize = strlen(buf);
< 	if (yp_match(ypDomain, map, buf, insize, &result, &outsize)
< 	 && yp_match(ypDomain, map, buf, insize+1, &result, &outsize))
< 	  {
< 	  	errno = 0;
< 		return;
< 	  }
< # ifdef DEBUG
< 	if (tTd(27, 1))
< 	    printf("Yellow pages found %s as value for %s\n",result,buf);
< # endif DEBUG
< 	if (outsize >= bufsize) outsize = bufsize - 1;
< 	strncpy(buf, result, outsize);
< 	buf[outsize] = '\0';
<   }
< 
< /*
< **  YELLOWLOOKUP -- look up a name in the Yellow Pages.
< **
< **	Parameters:
< **		a -- the address to look up.
< **
< **	Returns:
< **		the value of name.
< **		NULL if unknown.
< **
< **	Side Effects:
< **		sets 
< **
< **	Warnings:
< **		The return value will be trashed across calls.
< */
< 
< char *
< yellowlookup(a)
< 	register ADDRESS *a;
<   {
< 	char *result, *colon;
< 	int insize, outsize;
< 	extern char *AliasMap;
< 	
< 		/*
< 		 * if we did not find a local alias, then
< 		 * try a remote alias through yellow pages.
< 		 */
< 	if (AliasMap==NULL || *AliasMap=='\0') return(NULL);
< 
< 	if (ypDomain==NULL)
< 		{
< 		  yp_get_default_domain(&ypDomain);
< 		  if (ypDomain == NULL) return(NULL);
< # ifdef DEBUG
< 		  if (tTd(27, 1))
< 	    		printf("Yellow pages domain is %s\n",ypDomain);
< # endif DEBUG
< 		}
< 	if (bitset(QWASLOCAL,a->q_flags)) return(NULL);
< 	insize = strlen(a->q_user)+1;
< 	if (yp_match(ypDomain,AliasMap,a->q_user, insize, &result, &outsize))
< 	  {
<     	    errno = 0;
< 	    return(NULL);
< 	  }
<   
< # ifdef DEBUG
<         if (tTd(27, 1))
< 		printf("%s maps to %s\n",a->q_user, result );
< # endif DEBUG
< 	colon = index(result,':');
< 	if (index(result,'|') || 
< 	    (colon && strncmp(colon, ":include:", 9) == 0))
< 	  {
< 	  	/*
< 		 * Don't do domain-aliases for include files or pipes -
< 		 * just punt to the domain registry machine.
< 		 */
< 	    char buf[MAXNAME];
< 	    (void) strcpy(buf,a->q_user);
< 	    (void) strcat(buf,"@");
< 	    (void) strcat(buf,ypDomain);
< 	    return(newstr(buf));
< 	  }
< 	a->q_flags |= QDOMAIN;
< 	return(result);
< }
< #endif	YELLOWPAGES
406c216
< 			**	If you have a dbm_close() it can be
---
> 			**	If you have a dbmclose() it can be
409c219
< 			dbm_close();
---
> 
473,475d282
< #ifdef	YELLOWPAGES
< 		readaliases(aliasfile, TRUE, modtime);
< #else	YELLOWPAGES
477d283
< #endif	YELLOWPAGES
480,482d285
< #ifdef	YELLOWPAGES
< 	readaliases(aliasfile, init, modtime);
< #else	YELLOWPAGES
484d286
< #endif	YELLOWPAGES
506,511d307
< #ifdef	YELLOWPAGES
< readaliases(aliasfile, init, modtime)
< 	char *aliasfile;
< 	bool init;
< 	time_t modtime;
< #else	YELLOWPAGES
515d310
< #endif	YELLOWPAGES
529d323
< # ifdef DEBUG
532d325
< # endif
539d331
< # ifdef FLOCK
554d345
< # endif FLOCK
558,559c349
< 	**  If initializing, create the new DBM files. If YELLOWPAGES then
< 	**  reopen them in case they didn't exist.
---
> 	**  If initializing, create the new DBM files.
581,586c371
< 		if (dbminit(aliasfile)<0)
< 		{
< 			syserr("cannot open database %s",aliasfile);
< 			(void) signal(SIGINT, oldsigint);
< 			return;
< 		}
---
> 		dbminit(aliasfile);
601a387,389
> 		p = index(line, '\n');
> 		if (p != NULL)
> 			*p = '\0';
605d392
< 		  case '\n':
635c422
< 		if (parseaddr(line, &al, 0, ':') == NULL)
---
> 		if (parseaddr(line, &al, 1, ':') == NULL)
711,712d497
< 			free(al.q_user);
< 			al.q_user = NULL;
732,752d516
< #ifdef	YELLOWPAGES
< 		DATUM key, value;
< 		char last_modified[16];
< 
< 		    /*
< 		     * Add the special Yellow pages entries. We can do this
< 		     * without harm even if this host is not itself a YP server
< 		     */
< 		key.dptr = "YP_LAST_MODIFIED";
< 		key.dsize = strlen(key.dptr);
< 		sprintf(last_modified,"%10.10d",modtime);
< 		value.dptr = last_modified;
< 		value.dsize = strlen(value.dptr);
< 		store(key, value);
< 
< 		key.dptr = "YP_MASTER_NAME";
< 		key.dsize = strlen(key.dptr);
< 		value.dptr = (char *) macvalue('w',CurEnv);
< 		value.dsize = strlen(value.dptr);
< 		store(key, value);
< #else	YELLOWPAGES
754d517
< #endif	YELLOWPAGES
804d566
< # ifdef DEBUG
807d568
< # endif DEBUG
811d571
< # ifdef DEBUG
814d573
< # endif DEBUG
Only in sendmail/src: aliases.0
Only in sendmail/src: aliases.5
diff -r sendmail.target/src/arpadate.c sendmail/src/arpadate.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)arpadate.c	5.4 (Berkeley) 1/9/86";
< #endif not lint
---
> static char sccsid[] = "@(#)arpadate.c	5.10 (Berkeley) 1/8/89";
> #endif /* not lint */
16d23
< # ifdef USG
18,20d24
< # else
< # include <sys/time.h>
< # ifndef V6
22,24d25
< # include <sys/timeb.h>
< # endif V6
< # endif USG
27,37d27
< # ifdef V6
< # define OLDTIME
< # endif V6
< # ifdef USG
< # define OLDTIME
< # endif USG
< static bool fconvert();
< #ifdef	NEWTZCODE
< #define	OLDTIIME
< #endif	NEWTZCODE
< 
69a60,64
> 	register int off;
> 	register int i;
> 	register struct tm *lt;
> 	time_t t;
> 	struct tm gmt;
70a66
> 	extern struct tm *localtime(), *gmtime();
72,88c68
< 	register int i;
< 	extern struct tm *localtime();
< 	extern bool fconvert();
< # ifdef OLDTIME
< 	long t;
< 	extern long time();
< # else OLDTIME
< 	struct timeb t;
< 	extern struct timeb *ftime();
< 	extern char *timezone();
< # endif OLDTIME
< # ifdef V6
< 	extern char *StdTimezone, *DstTimezone;
< # endif V6
< # ifdef USG
< 	extern char *tzname[2];
< # endif USG
---
> 	extern time_t time();
96d75
< # ifdef OLDTIME
100,104d78
< # else
< 	ftime(&t);
< 	if (ud == NULL)
< 		ud = ctime(&t.time);
< # endif OLDTIME
142,186c116,123
< 				/* -PST or -PDT */
< # ifdef V6
< 	if (localtime(&t)->tm_isdst)
< 		p = DstTimezone;
< 	else
< 		p = StdTimezone;
< # else V6
< # ifdef	NEWTZCODE
< 	if ((p = localtime(&t)->tm_zone) == NULL)
< 		p = "???";	/* we couldn't figure it out */
< # else	NEWTZCODE
< # ifdef USG
< 	if (localtime(&t)->tm_isdst)
< 		p = tzname[1];
< 	else
< 		p = tzname[0];
< # else USG
< 	p = timezone(t.timezone, localtime(&t.time)->tm_isdst);
< # endif USG
< # endif NEWTZCODE
< # endif	V6
< 	if ((strncmp(p, "GMT", 3) == 0 || strncmp(p, "gmt", 3) == 0) &&
< 	    p[3] != '\0')
< 	{
< 		/* hours from GMT */
< 		p += 3;
< 		*q++ = *p++;
< 		if (p[1] == ':')
< 			*q++ = '0';
< 		else
< 			*q++ = *p++;
< 		*q++ = *p++;
< 		p++;		/* skip ``:'' */
< 		*q++ = *p++;
< 		*q++ = *p++;
< 		*q = '\0';
< 	}
< 	else if (!fconvert(p, q))
< 	{
< 		*q++ = ' ';
< 		*q++ = *p++;
< 		*q++ = *p++;
< 		*q++ = *p++;
< 		*q = '\0';
< 	}
---
> 	/*
> 	 * should really get the timezone from the time in "ud" (which
> 	 * is only different if a non-null arg was passed which is different
> 	 * from the current time), but for all practical purposes, returning
> 	 * the current local zone will do (its all that is ever needed).
> 	 */
> 	gmt = *gmtime(&t);
> 	lt = localtime(&t);
188,205c125
< 	return (b);
< }
< /*
< **  FCONVERT -- convert foreign timezones to ARPA timezones
< **
< **	This routine is essentially from Teus Hagen.
< **
< **	Parameters:
< **		a -- timezone as returned from UNIX.
< **		b -- place to put ARPA-style timezone.
< **
< **	Returns:
< **		TRUE -- if a conversion was made (and b was filled in).
< **		FALSE -- if this is not a recognized local time.
< **
< **	Side Effects:
< **		none.
< */
---
> 	off = (lt->tm_hour - gmt.tm_hour) * 60 + lt->tm_min - gmt.tm_min;
207,212c127,135
< /* UNIX to arpa conversion table */
< struct foreign
< {
< 	char *f_from; 
< 	char *f_to; 
< };
---
> 	/* assume that offset isn't more than a day ... */
> 	if (lt->tm_year < gmt.tm_year)
> 		off -= 24 * 60;
> 	else if (lt->tm_year > gmt.tm_year)
> 		off += 24 * 60;
> 	else if (lt->tm_yday < gmt.tm_yday)
> 		off -= 24 * 60;
> 	else if (lt->tm_yday > gmt.tm_yday)
> 		off += 24 * 60;
214,224c137,147
< static struct foreign	Foreign[] =
< {
< /* According to ANSI standard X3.51-1975 */
< 	{ "EET",	"+0200" },	/* eastern europe */
< 	{ "MET",	"+0100" },	/* middle europe */
< 	{ "WET",	"GMT"   },	/* western europe */
< 	{ "EET DST",	"+0300" },	/* daylight saving times */
< 	{ "MET DST",	"+0200" },
< 	{ "WET DST",	"+0100" },
< 	{ NULL,		NULL	 }
< };
---
> 	*q++ = ' ';
> 	if (off == 0) {
> 		*q++ = 'G';
> 		*q++ = 'M';
> 		*q++ = 'T';
> 	} else {
> 		if (off < 0) {
> 			off = -off;
> 			*q++ = '-';
> 		} else
> 			*q++ = '+';
226,232c149,150
< static bool
< fconvert(a, b)
< 	register char *a;
< 	char *b;
< {
< 	register struct foreign *euptr;
< 	register char *p;
---
> 		if (off >= 24*60)		/* should be impossible */
> 			off = 23*60+59;		/* if not, insert silly value */
234,246c152,156
< 	for (euptr = Foreign; euptr->f_from != NULL; euptr++)
< 	{
< 		extern bool sameword();
< 
< 		if (sameword(euptr->f_from, a))
< 		{
< 			p = euptr->f_to;
< 			*b++ = ' ';
< 			while (*p != '\0')
< 				*b++ = *p++;
< 			*b = '\0';
< 			return (TRUE);
< 		}
---
> 		*q++ = (off / 600) + '0';
> 		*q++ = (off / 60) % 10 + '0';
> 		off %= 60;
> 		*q++ = (off / 10) + '0';
> 		*q++ = (off % 10) + '0';
248c158,160
< 	return (FALSE);
---
> 	*q = '\0';
> 
> 	return (b);
Only in sendmail.target/src: bcopy.c
Only in sendmail.target/src: bmove.11.s
Only in sendmail.target/src: bmove.c
Only in sendmail.target/src: bmove.vax.s
diff -r sendmail.target/src/clock.c sendmail/src/clock.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)clock.c	5.4 (Berkeley) 12/17/85";
< #endif not lint
---
> static char sccsid[] = "@(#)clock.c	5.7 (Berkeley) 1/1/89";
> #endif /* not lint */
18,19d25
< static endsleep();
< 
49d54
< # ifdef DEBUG
55d59
< # endif DEBUG
75d78
< # ifdef DEBUG
79d81
< # endif DEBUG
102d103
< # ifdef DEBUG
105d105
< # endif DEBUG
152d151
< # ifdef DEBUG
155d153
< # endif DEBUG
167d164
< # ifdef DEBUG
171d167
< # endif DEBUG
175c171
< # ifdef	SIGVTALRM
---
> #ifdef SIGVTALRM
178c174
< # endif SIGVTALRM
---
> #endif SIGVTALRM
diff -r sendmail.target/src/collect.c sendmail/src/collect.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)collect.c	5.2 (Berkeley) 6/8/85";
< #endif not lint
---
> static char sccsid[] = "@(#)collect.c	5.7 (Berkeley) 1/1/89";
> #endif /* not lint */
123a132
> 
132d140
< # ifdef DEBUG
135d142
< # endif DEBUG
165,167d171
< #if	NeXT_MOD
< 		CurEnv->e_bodysize += strlen(bp) + 1;
< #endif	NeXT_MOD
180c184,190
< 		syserr("collect: unexpected close, from=%s", CurEnv->e_from.q_paddr);
---
> # ifdef LOG
> 		if (RealHostName != NULL && LogLevel > 0)
> 			syslog(LOG_NOTICE,
> 			    "collect: unexpected close on connection from %s: %m\n",
> 			    CurEnv->e_from.q_paddr, RealHostName);
> # endif
> 		usrerr("collect: unexpected close, from=%s", CurEnv->e_from.q_paddr);
212d221
< # ifdef DEBUG
215d223
< # endif DEBUG
287d294
< # ifdef DEBUG
290d296
< # endif DEBUG
diff -r sendmail.target/src/conf.c sendmail/src/conf.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)conf.c	5.14 (Berkeley) 1/10/86";
< #endif not lint
---
> static char sccsid[] = "@(#)conf.c	5.17 (Berkeley) 6/30/88";
> #endif /* not lint */
22,26d29
< #if	NeXT_MOD
< #include <arpa/nameser.h>
< #include <resolv.h>
< #endif	NeXT_MOD
< 
33,37d35
< **		V6 -- running on a version 6 system.  This determines
< **			whether to define certain routines between
< **			the two systems.  If you are running a funny
< **			system, e.g., V6 with long tty names, this
< **			should be checked carefully.
80,82d77
< #if	NeXT_MOD
< 	"errors-to",		H_FROM|H_ERRSTO,
< #else	NeXT_MOD
84d78
< #endif	NeXT_MOD
124,130d117
< #if	NeXT_MOD
< char	*ConfFile =	"/etc/sendmail/sendmail.cf";
< 						/* runtime configuration */
< char	*ConfFile2 =	"/usr/lib/sendmail.cf";	/* Alternate configuration */
< char	*FreezeFile =	"/etc/sendmail/sendmail.fc";
< 						/* frozen version of above */
< #else	NeXT_MOD
133d119
< #endif	NeXT_MOD
134a121,122
> 
> 
140,143d127
< #ifdef	YELLOWPAGES
< char	*AliasMap;		/* Yellow Pages aliases map */
< #endif	YELLOWPAGES
< 
163,166d146
< #if	NeXT_MOD
< 	QueueLA =	0;	/* load avg > QueueLA -> just queue */
< 	RefuseLA =	0;	/* load avg > RefuseLA -> refuse connections */
< #else	NeXT_MOD
168,169d147
< 	RefuseLA = 12;
< #endif	NeXT_MOD
171c149,150
< 	SpaceSub = ' ';		/* character to replace <lwsp> in addrs */
---
> 	RefuseLA = 12;
> 	SpaceSub = ' ';
178,183d156
< #ifdef	YELLOWPAGES
< 	AliasMap = ALIAS_MAP;	/* Yellow Pages aliases map */
< #endif	YELLOWPAGES
< #if	NeXT_MOD
< 	CheckPointLimit = 999;	/* disable as default */	
< #endif	NeXT_MOD
186,207d158
< #if	NeXT_MOD
< initdomain()
< {
< 	/*
< 	 * We use Internet domains.  This gets the default domain name
< 	 * from the resolver
< 	 */
< 	char buf[MAXNAME];
< 	char *autodomain;
< 	extern struct state _res;
< 
< 	res_init();
< 	if (_res.defdname[0] == '\0') {
< 		return;
< 	}
< 	autodomain = newstr(_res.defdname);
< 	define('m', autodomain, CurEnv);
< 	setclass('m', autodomain);
< }
< #endif	NeXT_MOD
< 
< # ifdef V6
209,365d159
< **  TTYNAME -- return name of terminal.
< **
< **	Parameters:
< **		fd -- file descriptor to check.
< **
< **	Returns:
< **		pointer to full path of tty.
< **		NULL if no tty.
< **
< **	Side Effects:
< **		none.
< */
< 
< char *
< ttyname(fd)
< 	int fd;
< {
< 	register char tn;
< 	static char pathn[] = "/dev/ttyx";
< 
< 	/* compute the pathname of the controlling tty */
< 	if ((tn = ttyn(fd)) == NULL)
< 	{
< 		errno = 0;
< 		return (NULL);
< 	}
< 	pathn[8] = tn;
< 	return (pathn);
< }
< /*
< **  FDOPEN -- Open a stdio file given an open file descriptor.
< **
< **	This is included here because it is standard in v7, but we
< **	need it in v6.
< **
< **	Algorithm:
< **		Open /dev/null to create a descriptor.
< **		Close that descriptor.
< **		Copy the existing fd into the descriptor.
< **
< **	Parameters:
< **		fd -- the open file descriptor.
< **		type -- "r", "w", or whatever.
< **
< **	Returns:
< **		The file descriptor it creates.
< **
< **	Side Effects:
< **		none
< **
< **	Called By:
< **		deliver
< **
< **	Notes:
< **		The mode of fd must match "type".
< */
< 
< FILE *
< fdopen(fd, type)
< 	int fd;
< 	char *type;
< {
< 	register FILE *f;
< 
< 	f = fopen("/dev/null", type);
< 	(void) close(fileno(f));
< 	fileno(f) = fd;
< 	return (f);
< }
< /*
< **  INDEX -- Return pointer to character in string
< **
< **	For V7 compatibility.
< **
< **	Parameters:
< **		s -- a string to scan.
< **		c -- a character to look for.
< **
< **	Returns:
< **		If c is in s, returns the address of the first
< **			instance of c in s.
< **		NULL if c is not in s.
< **
< **	Side Effects:
< **		none.
< */
< 
< char *
< index(s, c)
< 	register char *s;
< 	register char c;
< {
< 	while (*s != '\0')
< 	{
< 		if (*s++ == c)
< 			return (--s);
< 	}
< 	return (NULL);
< }
< /*
< **  UMASK -- fake the umask system call.
< **
< **	Since V6 always acts like the umask is zero, we will just
< **	assume the same thing.
< */
< 
< /*ARGSUSED*/
< umask(nmask)
< {
< 	return (0);
< }
< 
< 
< /*
< **  GETRUID -- get real user id.
< */
< 
< getruid()
< {
< 	return (getuid() & 0377);
< }
< 
< 
< /*
< **  GETRGID -- get real group id.
< */
< 
< getrgid()
< {
< 	return (getgid() & 0377);
< }
< 
< 
< /*
< **  GETEUID -- get effective user id.
< */
< 
< geteuid()
< {
< 	return ((getuid() >> 8) & 0377);
< }
< 
< 
< /*
< **  GETEGID -- get effective group id.
< */
< 
< getegid()
< {
< 	return ((getgid() >> 8) & 0377);
< }
< 
< # endif V6
< 
< # ifndef V6
< 
< /*
390,391c184
< # endif V6
< /*
---
> /*
430,437d222
< #if	NeXT_MOD
< 			if (getuid() != pw->pw_uid && getuid() != 0)
< 			  /*
< 			   * If anyone except root does an su command,
< 			   * then use the current user, not the one from 
< 			   * getlogin
< 			   */
< #else	NeXT_MOD
439d223
< #endif	NeXT_MOD
615c399
< 	{{ "_avenrun" }},
---
> 	{ "_avenrun" },
617c401
< 	{{ 0 }},
---
> 	{ 0 },
684,686d467
< #if	NeXT_MOD
< 	if (QueueLA == 0) return(FALSE);
< #endif	NeXT_MOD
diff -r sendmail.target/src/conf.h sendmail/src/conf.h
2,11c2,19
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< **
< **	@(#)conf.h	5.7 (Berkeley) 1/5/86
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  *
>  *	@(#)conf.h	5.15 (Berkeley) 1/1/89
>  */
17d24
< #if	NeXT_MOD
19,24d25
<  * Reject messages to large mailing lists that have no body.
<  */
< # define REJECT_MIN		10		/* minimum bytes in body */
< #endif	NeXT_MOD
< 
< /*
36,38d36
< #if	NeXT_MOD
< # define MAXRWSETS	50		/* max # of sets of rewriting rules */
< #else	NeXT_MOD
40d37
< #endif	NeXT_MOD
45d41
< #if	NeXT_MOD
47d42
< #endif	NeXT_MOD
57d51
< # define DEBUG		1	/* enable debugging */
63d56
< # define FLOCK		1	/* use flock file locking */
65,68c58
< /* # define WIZ		1	/* allow wizard mode */
< /* #define NEWTZCODE	1	/* use new timezone code */
< /*#define USG		1	/* building for USG (S3, S5) system */
< # define SCANF		1	/* enable scanf format in F lines */
---
> # define NAMED_BIND	1	/* use Berkeley Internet Domain Server */
70,76c60,68
< #ifdef	YELLOWPAGES
< # define YELLOW		1	/* Call yellow pages for aliases */
< # define ALIAS_MAP	"mail.aliases"	/* default yp map for aliases */
< #endif	YELLOWPAGES
< 
< # define FreezeMode 	0644	/* creation mode for Freeze file: */
< 				/* Must be public read if using NFS */
---
> 	/*
> 	 * Use query type of ANY if possible (NO_WILDCARD_MX), which will
> 	 * find types CNAME, A, and MX, and will cause all existing records
> 	 * to be cached by our local server.  If there is (might be) a
> 	 * wildcard MX record in the local domain or its parents that are
> 	 * searched, we can't use ANY; it would cause fully-qualified names
> 	 * to match as names in a local domain.
> 	 */
> # define NO_WILDCARD_MX	1
diff -r sendmail.target/src/convtime.c sendmail/src/convtime.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)convtime.c	5.1 (Berkeley) 6/7/85";
< #endif not lint
---
> static char sccsid[] = "@(#)convtime.c	5.3 (Berkeley) 6/30/88";
> #endif /* not lint */
diff -r sendmail.target/src/daemon.c sendmail/src/daemon.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
10a19,20
> #include <errno.h>
> #include <sendmail.h>
12,13c22,28
< # include <errno.h>
< # include "sendmail.h"
---
> #ifndef lint
> #ifdef DAEMON
> static char sccsid[] = "@(#)daemon.c	5.30 (Berkeley) 1/19/89 (with daemon mode)";
> #else
> static char sccsid[] = "@(#)daemon.c	5.30 (Berkeley) 1/19/89 (without daemon mode)";
> #endif
> #endif /* not lint */
15c30
< # ifdef DAEMON
---
> #ifdef DAEMON
17,21c32
< # include <netdb.h>		/* FIXME: Do I want this to be "netdb.h"? */
< #if	NeXT_MOD
< #include <sys/wait.h>
< #include <sys/param.h>
< #else	NeXT_MOD
---
> # include <netdb.h>
26d36
< #endif	NeXT_MOD
28,31d37
< # ifndef lint
< static char	SccsId[] = "@(#)daemon.c	5.19 (Berkeley) 5/6/86 (with daemon mode)";
< # endif not lint
< 
35c41
< **	This entire file is highly dependent on the BSD
---
> **	This entire file is highly dependent on the 4.2 BSD
56c62
< **		success, else an exit status and errno describing the
---
> **		success, else an exit status describing the
61,69d66
< **	lookuphost(host)
< **		Look up the host to determine an address.  Return
< **		the address of a struct hostinfo about the host, which
< **		may be modified by the caller if desired.
< **	closeconnection(fd)
< **		Marks the host which we connected to via file desc 'fd'
< **		as closed, so we won't try to reuse the connection.
< **		Note that this does not actually close the file
< **		descriptor.  That's the caller's responsibility.
71,195d67
< #if	NeXT_MOD
< static struct hostinfo *host_from_fd[NOFILE];	/* Host entry for each */
< 
< 
< static setuphost(sp, hp)
<     STAB *sp;
<     struct hostent *hp;
<   {
< # if BSD >= 43
<     int i;
<     for (i= 0; i < MAXMXHOSTS && *hp->h_addr_list; i++)
< 	sp->s_value.sv_host.h_addrlist[ i ] = 
< 		*(struct in_addr *)(*hp->h_addr_list++);
<     sp->s_value.sv_host.h_addrlist[ i ].s_addr = INADDR_ANY;
< # else 
<     sp->s_value.sv_host.h_addrlist[ 0 ] = *(struct in_addr *)(hp->h_addr);
<     sp->s_value.sv_host.h_addrlist[ 1 ].s_addr = INADDR_ANY;
< # endif
<   }
< 
< static jmp_buf NameTimeout;
< time_t nametime = 90;		/* seconds to wait for name server */
< 
< nametimeout()  {longjmp(NameTimeout, 1);}
< 
< /*
< **  LOOKUPHOST -- determine host address and other remembered info.
< **
< **	Parameters:
< **		host -- a char * providing a host name or [a.b.c.d].
< **
< **	Returns:
< **		The address of a struct hostinfo for this host.
< **		The caller may modify h_fd, h_down, and h_open in
< **		this structure.  h_addr and h_exists should not be
< **		modified.
< **
< **	Side Effects:
< **		If the hostname has previously been looked up, the
< **		existing symbol table entry is returned immediately.
< **		Otherwise, a new symbol table entry is created, 
< **		a system-dependent hostname->address lookup is done,
< **		and the new entry is returned.
< **
< **		Note that for information to be remembered in the
< **		symbol table, the process must do several lookups
< **		without forking and exiting.
< */
< struct hostinfo *
< lookuphost(host)
< 	char *host;			/* Host name */
< {
< 	register struct hostent *hp = (struct hostent *)NULL;
< 	extern char *inet_ntoa();
< 	STAB	*sp;			/* Symbol table entry */
< 	EVENT *ev;
< 
< 	sp = stab(host, ST_HOST, ST_ENTER);
< 	if (sp->s_value.sv_host.h_valid) {
< 		AlreadyKnown = sp->s_value.sv_host.h_down;
< 		return &sp->s_value.sv_host;
< 	}
< 
< 	/*
< 	**  Create a new symbol table entry.  Initially it is cleared,
< 	**  thus h_exists is 0.  Ditto for the other flags.
< 	**  Then look up the address for the host.
< 	**	Accept "[a.b.c.d]" syntax for host name.
< 	*/
< 	sp->s_value.sv_host.h_valid = 1;
< 	if (host[0] == '[')
< 	{
< 		long hid;
< 		register char *p = index(host, ']');
< 
< 		if (p != NULL)
< 		{
< 			*p = '\0';
< 			hid = inet_addr(&host[1]);
< 			*p = ']';
< 		}
< 		if (p == NULL || hid == -1)
< 		{
< 			usrerr("Invalid numeric domain spec \"%s\"", host);
< 		}
< 		else
< 		{
< 			sp->s_value.sv_host.h_addrlist[0].s_addr = hid;
< 			sp->s_value.sv_host.h_index = 0;
< 			sp->s_value.sv_host.h_exists = 1;
< 		}
< 		return &sp->s_value.sv_host;		/* Return [] entry */
< 	}
< 
< 	if (setjmp(NameTimeout) != 0) {
< 		sp->s_value.sv_host.h_exists = 1;
< 		sp->s_value.sv_host.h_down = 1;
< 		sp->s_value.sv_host.h_errno = ENAMESER;
< 		return &sp->s_value.sv_host;
< 	}
< 	ev = setevent(nametime, nametimeout, 0);
< 	hp = gethostbyname(host);
< 	if (hp != NULL && hp->h_addrtype == AF_INET)
< 	{
< 		setuphost(sp, hp);
< 		sp->s_value.sv_host.h_index = 0;
< 		sp->s_value.sv_host.h_exists = 1;
< 	}
< # ifdef MXDOMAIN
<    /*
<     * The gethostbyname failed -- in 4.2BSD we just return
<     * a hard error.  4.3BSD gives us more infomation on the failure.
<     */
< 	else if (h_errno == TRY_AGAIN) 
< 	{
< 		sp->s_value.sv_host.h_exists = 1;
< 
< 		sp->s_value.sv_host.h_down = 1;
< 		sp->s_value.sv_host.h_errno = ENAMESER;
< 	}
< # endif MXDOMAIN
< 	clrevent(ev);
< 	return &sp->s_value.sv_host;		/* Return new entry */
< }
< #endif	NeXT_MOD
244d115
< # ifdef DEBUG
247d117
< # endif DEBUG
257,258d126
< #if	NeXT_MOD
< # ifdef LOG_SALERT
260,266d127
< 			syslog(LOG_SALERT, "cannot get connection");
< # else LOG_SALERT
< 		if (LogLevel > 0)
< 			syslog(LOG_CRIT|LOG_MAIL, "cannot get connection");
< # endif LOG_SALERT
< #else	NeXT_MOD
< 		if (LogLevel > 0)
268d128
< #endif	NeXT_MOD
273d132
< #ifdef DEBUG
277d135
< #endif DEBUG
282,283c140
< 	if (bind(DaemonSocket, (struct sockaddr *) &SendmailAddress,
< 		 sizeof SendmailAddress) < 0)
---
> 	if (bind(DaemonSocket, &SendmailAddress, sizeof SendmailAddress) < 0)
298d154
< # ifdef DEBUG
301d156
< # endif DEBUG
303,308d157
< #if	NeXT_MOD
< # ifdef LOG
< 	/* Tell the log that a new daemon has started. */
< 	syslog(LOG_INFO, "network daemon starting");
< # endif LOG
< #endif	NeXT_MOD
313d161
< 		struct sockaddr_in otherend;
314a163
> 		register int la;
317,321c166,168
< #if	NeXT_MOD
< 		while (RefuseLA > 0 && getla() > RefuseLA)
< #else	NeXT_MOD
< 		while (getla() > RefuseLA)
< #endif	NeXT_MOD
---
> 		while ((la = getla()) > RefuseLA)
> 		{
> 			setproctitle("rejecting connections: load average: %.2f", la);
322a170
> 		}
324a173
> 		setproctitle("accepting connections");
328,330c177,178
< 			lotherend = sizeof otherend;
< 			t = accept(DaemonSocket, (struct sockaddr *)&otherend,
< 			    &lotherend);
---
> 			lotherend = sizeof RealHostAddr;
> 			t = accept(DaemonSocket, &RealHostAddr, &lotherend);
343d190
< # ifdef DEBUG
346d192
< # endif DEBUG
362,364c208
< #if	NeXT_MOD
< 			EVENT *ev;
< #endif	NeXT_MOD
---
> 
373,384d216
< #if	NeXT_MOD
< 			/* determine host name with timeout */
< 			if (setjmp(NameTimeout) != 0) {
< 			    hp = NULL;
< 			}
< 			else {
< 			    ev = setevent(nametime, nametimeout, 0);
< 			    hp = gethostbyaddr(
< 		&otherend.sin_addr, sizeof otherend.sin_addr, AF_INET);
< 			    clrevent(ev);
< 			}
< #else	NeXT_MOD
386,387c218
< 			hp = gethostbyaddr((char *) &otherend.sin_addr, sizeof otherend.sin_addr, AF_INET);
< #endif	NeXT_MOD
---
> 			hp = gethostbyaddr((char *) &RealHostAddr.sin_addr, sizeof RealHostAddr.sin_addr, AF_INET);
389d219
< 			{
391,397d220
< 				if (NetName != NULL && NetName[0] != '\0' &&
< 				    index(hp->h_name, '.') == NULL)
< 				{
< 					(void) strcat(buf, ".");
< 					(void) strcat(buf, NetName);
< 				}
< 			}
404c227
< 					inet_ntoa(otherend.sin_addr));
---
> 					inet_ntoa(RealHostAddr.sin_addr));
411,414d233
< #if	NeXT_MOD
< 			setproctitle("From %s", (int)RealHostName);
< 			define('r', "TCP", CurEnv);
< #endif	NeXT_MOD
417,419d235
< #if	NeXT_MOD
< 			OutChannel = fdopen(t, "w");
< #else	NeXT_MOD
421,422d236
< #endif	NeXT_MOD
< # ifdef DEBUG
425d238
< # endif DEBUG
472,479c285
< **	  For NeXT_MOD:
< **		On an error, global <errno> is set describing the error.
< **		A previously existing connection will be reused.
< **		Previously cached data will be used to find the host
< **			and determine its status.  This cache is updated
< **			with the host's current status.
< **	  Otherwise:
< **		None.
---
> **		none.
482,487d287
< #if	NeXT_MOD
< #define	IPPORT_SMTP	25
< #else	NeXT_MOD
< int	h_errno;	/*this will go away when code implemented*/
< #endif	NeXT_MOD
< 
494,495c294,295
< #if	NeXT_MOD
< 	register struct hostinfo *hp;
---
> 	register int i, s;
> 	register struct hostent *hp = (struct hostent *)NULL;
497,550d296
< 	int s;
< 	struct sockaddr_in	addr;
< 
< 
< 	/* Remember who we're talking to, for error messages */
< 	RealHostName = newstr(host);
< 
< 	/*
< 	**  Determine the address of the host.
< 	**  If we have tried to connect before and failed, don't try,
< 	**  Unless this is the last attempt.
< 	*/
< 	setproctitle("%s To %s", CurEnv->e_id, RealHostName);
< 	AlreadyKnown = FALSE;
< 	hp = lookuphost(host);
< 	errno = 0;
< 	if (!hp->h_exists)
< 		return (EX_NOHOST);
< 	if (hp->h_down && (curtime() < CurEnv->e_ctime + TimeOut))
< 	{
< 		errno = hp->h_errno;	/* for a better message */
< 		return (EX_TEMPFAIL);
< 	}
< 	addr.sin_family = AF_INET;
< 	addr.sin_addr = hp->h_addrlist[hp->h_index];
< 
< 	/*
< 	**  Determine the port number.
< 	*/
< 	if (port != 0)
< 		addr.sin_port = htons(port);
< 	else
< 		addr.sin_port = htons(IPPORT_SMTP);
< 
< 	if (!hp->h_open || hp->h_port != port)
< 	{
< 		s = openhost(hp, addr);
< 		if (s != EX_OK) return s;
< 	}
< 	*outfile = fdopen(hp->h_fd, "w");
< 	*infile = fdopen(dup(hp->h_fd), "r");
< 	return (EX_OK);
< }
< 
< int
< openhost(hp, addr)
< 	struct hostinfo *hp;
< 	struct sockaddr_in	addr;
< {
< 	register int s;
< 	int error_code;
< 	int on = 1;
< #else	NeXT_MOD
< 	register int s;
551a298,300
> #ifdef NAMED_BIND
> 	extern int h_errno;
> #endif
557a307
> #ifdef NAMED_BIND
558a309
> #endif
581,582c332
< 		register struct hostent *hp = gethostbyname(host);
< 
---
> 		hp = gethostbyname(host);
584a335
> #ifdef NAMED_BIND
587a339,343
> 			/* if name server is specified, assume temp fail */
> 			if (errno == ECONNREFUSED && UseNameServer)
> 				return (EX_TEMPFAIL);
> #endif
> 
595a352
> 		i = 1;
616d372
< #endif	NeXT_MOD
621c377
< # ifdef DEBUG
---
> again:
623,628c379,380
< #if	NeXT_MOD
< 		printf("openhost (%x)\n", hp->h_addrlist[hp->h_index].s_addr);
< #else	NeXT_MOD
< 		printf("makeconnection (%s)\n", host);
< #endif	NeXT_MOD
< # endif DEBUG
---
> 		printf("makeconnection (%s [%s])\n", host,
> 		    inet_ntoa(SendmailAddress.sin_addr.s_addr));
630,641d381
< #if	NeXT_MOD
< 	if (hp->h_addrlist[hp->h_index].s_addr == INADDR_ANY)
< 		 /*
< 		  * restart the address list search if we hit the end,
< 		  * otherwise use the last one that worked.
< 		  */
< 		hp->h_index = 0;
< 	for ( ;*(int *)&(hp->h_addrlist[hp->h_index]);hp->h_index++) {
< 
< 	addr.sin_addr = hp->h_addrlist[hp->h_index];
< #endif	NeXT_MOD
< 
645,646d384
< #if	NeXT_MOD
< 		error_code = errno;	/* Save errno for <failure> */
648,650d385
< 		errno = error_code;	/* Save errno for <failure> */
< #else	NeXT_MOD
< 		syserr("makeconnection: no socket");
652d386
< #endif	NeXT_MOD
656d389
< # ifdef DEBUG
666,695d398
< # endif DEBUG
< #if	NeXT_MOD
< 	if (Verbose) {
< 		printf("Trying %s... ", inet_ntoa(addr.sin_addr) );
< 		fflush(stdout);
< 	}
< 
< 	(void) setsockopt(DaemonSocket, SOL_SOCKET, SO_KEEPALIVE,
< 				 &on, sizeof(on));
< 
< 	if (CurEnv->e_xfp)
< 	    (void) fflush(CurEnv->e_xfp);
< 
< 	errno = 0;					/* for debugging */
< 	hp->h_tried = 1;		/* We are trying to connect */
< 	if (connect(s, (struct sockaddr *)&addr, sizeof addr) < 0)
< 	{
< 		/* failure, decide if temporary or not */
< 	failure:
< 		error_code = errno;
< 		(void) close(s);	/* Free the socket */
< 		if (Verbose)
< 		    printf("%s\r\n", errstring(error_code) );
< 		errno = error_code;
< 		switch (errno)
< 		{
< 		  case ETIMEDOUT:
< 		  	errno = EHOSTDOWN;	/* for a better message */
< 		  case EISCONN:
< #else	NeXT_MOD
702a406,412
> 		if (hp && hp->h_addr_list[i])
> 		{
> 			bcopy(hp->h_addr_list[i++],
> 			    (char *)&SendmailAddress.sin_addr, hp->h_length);
> 			goto again;
> 		}
> 
709d418
< #endif	NeXT_MOD
721d429
< #if	NeXT_MOD
723,725d430
< 			continue;
< #else	NeXT_MOD
< 			/* there are others, I'm sure..... */
734d438
< #endif	NeXT_MOD
735a440
> 			message(Arpa_Info, "%s", errstring(sav_errno));
740,742d444
< #if	NeXT_MOD
< 	if (Verbose)
< 	    printf(" connected.\r\n");
744,762d445
< 	host_from_fd[s] = hp;	/* Create cross reference pointer */
< 	hp->h_port = addr.sin_port;
< 	hp->h_fd = s;		/* Save file descriptor */
< 	hp->h_open = 1;		/* And indicate that it's open */
<   
<   	return (EX_OK);
< 	}
< 	
< 	hp->h_down = 1;		/* Mark down host */
< 	hp->h_errno = errno;
< 	/*
< 	** Note that the down flag is never turned off.
< 	** We depend on sendmail's exiting to throw away
< 	** this information.  It should apply to one
< 	** queue run only.
< 	*/
< 	return (EX_TEMPFAIL);
< #else	NeXT_MOD
< 	/* connection ok, put it into canonical form */
767d449
< #endif	NeXT_MOD
769,799d450
< 
< #if	NeXT_MOD
< /*
< **  CLOSECONNECTION -- mark an open connection as closed.
< **
< **	Parameters:
< **		fd -- the file descriptor of the connection.
< **
< **	Returns:
< **		none.
< **
< **	Side Effects:
< **		Marks the host (which had a connection opened via
< **		makeconnection()) as not having a current connection.
< **		Note that this does not actually close the file
< **		descriptor.  That's the caller's responsibility.
< */
< closeconnection(fd)
< 	int fd;
< {
< 	register struct hostinfo *hp;
< 
< 	if (fd < NOFILE) {
< 		hp = host_from_fd[fd];
< 		if (hp != NULL && hp->h_open) {
< 			hp->h_open = 0;
< 		}
< 		host_from_fd[fd] = NULL;
< 	}
< }
< #endif	NeXT_MOD
829c480
< 		(void) strncpy(hostbuf, hp->h_name, size-1);
---
> 		(void) strcpy(hostbuf, hp->h_name);
835,850d485
< /*
< **  MAPHOSTNAME -- turn a hostname into canonical form
< **
< **	Parameters:
< **		hbuf -- a buffer containing a hostname.
< **		hbsize -- the size of hbuf.
< **
< **	Returns:
< **		none.
< **
< **	Side Effects:
< **		Looks up the host specified in hbuf.  If it is not
< **		the canonical name for that host, replace it with
< **		the canonical name.  If the name is unknown, or it
< **		is already the canonical name, leave it unchanged.
< */
851a487,502
> /*
>  *  MAPHOSTNAME -- turn a hostname into canonical form
>  *
>  *	Parameters:
>  *		hbuf -- a buffer containing a hostname.
>  *		hbsize -- the size of hbuf.
>  *
>  *	Returns:
>  *		none.
>  *
>  *	Side Effects:
>  *		Looks up the host specified in hbuf.  If it is not
>  *		the canonical name for that host, replace it with
>  *		the canonical name.  If the name is unknown, or it
>  *		is already the canonical name, leave it unchanged.
>  */
857c508,510
< 	extern struct hostent *gethostbyname();
---
> 	u_long in_addr;
> 	char ptr[256];
> 	struct hostent *gethostbyaddr();
860,884c513,518
< 	**  If first character is a bracket, then it is an address
< 	**  lookup.  Address is copied into a temporary buffer to
< 	**  strip the brackets and to preserve hbuf if address is
< 	**  unknown.
< 	*/
< 
< 	if (*hbuf == '[')
< 	{
< 		extern struct hostent *gethostbyaddr();
< 		u_long in_addr;
< 		char ptr[256];
< 		char *bptr;
< 
< 		(void) strcpy(ptr, hbuf);
< 		bptr = index(ptr,']');
< 		*bptr = '\0';
< 		in_addr = inet_addr(&ptr[1]);
< 		hp = gethostbyaddr((char *) &in_addr, sizeof(struct in_addr), AF_INET);
< 		if (hp == NULL)
< 			return;
< 	}
< 	else
< 	{
< 		makelower(hbuf);
< #ifdef MXDOMAIN
---
> 	 * If first character is a bracket, then it is an address
> 	 * lookup.  Address is copied into a temporary buffer to
> 	 * strip the brackets and to preserve hbuf if address is
> 	 * unknown.
> 	 */
> 	if (*hbuf != '[') {
887,889d520
< #else MXDOMAIN
< 		hp = gethostbyname(hbuf);
< #endif MXDOMAIN
891,902c522,529
< 	if (hp != NULL)
< 	{
< 		int i = strlen(hp->h_name);
< 
< 		if (i >= hbsize)
< #if	NeXT_MOD
< 			hp->h_name[hbsize - 1] = '\0';
< #else	NeXT_MOD
< 			hp->h_name[--i] = '\0';
< #endif	NeXT_MOD
< 		(void) strcpy(hbuf, hp->h_name);
< 	}
---
> 	*index(strcpy(ptr, hbuf), ']') = '\0';
> 	in_addr = inet_addr(&ptr[1]);
> 	hp = gethostbyaddr((char *)&in_addr, sizeof(struct in_addr), AF_INET);
> 	if (hp == NULL)
> 		return;
> 	if (strlen(hp->h_name) >= hbsize)
> 		hp->h_name[hbsize - 1] = '\0';
> 	(void)strcpy(hbuf, hp->h_name);
904,908d530
< 
< # else DAEMON
< # ifndef lint
< static char	SccsId[] = "@(#)daemon.c	5.19 (Berkeley) 5/6/86	(w/o daemon mode)";
< # endif not lint
909a532
> # else DAEMON
Only in sendmail.target/src: dbm.h
diff -r sendmail.target/src/deliver.c sendmail/src/deliver.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)deliver.c	5.10 (Berkeley) 3/2/86";
< #endif not lint
---
> static char sccsid[] = "@(#)deliver.c	5.26 (Berkeley) 1/1/89";
> #endif /* not lint */
15,27c23,32
< # include <signal.h>
< # include <errno.h>
< # include "sendmail.h"
< # include <sys/stat.h>
< #if	NeXT_MOD
< static struct mxinfo *mx;	/* "current" mx record information */
< # ifndef MXDOMAIN
< struct mxinfo dummy_mx;		/* dummy mx info when not used */
< # endif MXDOMAIN
< extern char	Arpa_Usrerr[];
< #else	NeXT_MOD
< # include <netdb.h>
< #endif	NeXT_MOD
---
> #include <sendmail.h>
> #include <sys/signal.h>
> #include <sys/stat.h>
> #include <netdb.h>
> #include <fcntl.h>
> #include <errno.h>
> #ifdef NAMED_BIND
> #include <arpa/nameser.h>
> #include <resolv.h>
> #endif
58,61d62
< #if	NeXT_MOD
< 	int sizeleft;			/* Bytes of argv left to work with */
< 	int buflen;			/* Temp */
< #endif	NeXT_MOD
69c70
< 	register int rcode;		/* response code */
---
> 	int rcode;		/* response code */
81a83,90
> #ifdef NAMED_BIND
> 	/* unless interactive, try twice, over a minute */
> 	if (OpMode == MD_DAEMON || OpMode == MD_SMTP) {
> 		_res.retrans = 30;
> 		_res.retry = 2;
> 	}
> #endif NAMED_BIND
> 
85d93
< # ifdef DEBUG
89d96
< # endif DEBUG
136,138d142
< #if	NeXT_MOD
< 	sizeleft = m->m_argvsize - 10;		/* Leave some slop */
< #endif	NeXT_MOD
140,142d143
< #if	NeXT_MOD
< 	sizeleft -= strlen(m->m_argv[0]) + 1;
< #endif	NeXT_MOD
174,176d174
< #if	NeXT_MOD
< 		sizeleft -= strlen(buf) + 1;
< #endif	NeXT_MOD
229d226
< # ifdef DEBUG
235d231
< # endif DEBUG
243,244d238
< #if	NeXT_MOD
< #else	NeXT_MOD
246d239
< #endif	NeXT_MOD
255d247
< 			usrerr("Message is too large; %ld bytes max", m->m_maxsize);
256a249
> 			usrerr("Message is too large; %ld bytes max", m->m_maxsize);
258,260d250
< #if	NeXT_MOD
< 			to->q_flags |= QDONTSEND;
< #endif	NeXT_MOD
266,268d255
< #if	NeXT_MOD
< 			to->q_flags |= QDONTSEND;
< #endif	NeXT_MOD
301,327d287
< #if	NeXT_MOD
< 		if (bitset(QBADADDR|QQUEUEUP, to->q_flags)) {
< 			to->q_flags |= QDONTSEND;
< 			continue;
< 		}
< 
< 		/*
< 		**  Expand out this user and see if it fits in argv.
< 		**  By definition, the first user always fits, else
< 		**  we would loop here for rather a long time.
< 		*/
< 		define('u', user, e);		/* to user */
< 		define('z', to->q_home, e);	/* user's home */
< 		expand(*mvp, buf, &buf[sizeof buf - 1], e);
< 		buflen = strlen(buf);
< 
< 		if (buflen > sizeleft && tobuf[0] != '\0')
< 			break;		/* Stop argv here */
< 
< 		/*
< 		**  We have decided that we are sending the message to
< 		**  this user now.  First mark it to avoid resending
< 		**  later.
< 		*/
< 
< 		to->q_flags |= QDONTSEND;
< #else	NeXT_MOD
333d292
< #endif	NeXT_MOD
349,351d307
< #if	NeXT_MOD
< 				markstats(e, to);
< #endif	NeXT_MOD
356d311
< #if	NeXT_MOD
358,362d312
< 		**  Add this user to mailer argv, and add it
< 		**  to the print list of recipients.
< 		*/
< #else	NeXT_MOD
< 		/*
366d315
< #endif	NeXT_MOD
375,380d323
< #if	NeXT_MOD
< 		if (!clever)
< 		{
< 			*pvp++ = newstr(buf);
< 			sizeleft -= buflen + 1;
< #else	NeXT_MOD
392d334
< #endif	NeXT_MOD
413,416d354
< 	**  NeXT_NFS: Note that these are not checked against "sizeleft",
< 	**  thus are not counted in the mailer L= option.  The L= value just
< 	**  has to subtract off the max length of any trailing parameters,
< 	**  or figure out how to move them to the front instead.
436,441d373
< #if	NeXT_MOD
< 	message(Arpa_Info, "Connecting to %s via %s...", host, m->m_name);
< #else	NeXT_MOD
< 	message(Arpa_Info, "Connecting to %s.%s...", host, m->m_name);
< #endif	NeXT_MOD
< 
444c376,379
< # ifdef SMTP
---
> #ifdef NAMED_BIND
> 	_res.options &= ~(RES_DEFNAMES | RES_DNSRCH);		/* XXX */
> #endif
> #ifdef SMTP
447,453c382,385
< #if	NeXT_MOD
< # ifdef MXDOMAIN
< 		extern struct mxinfo *getmxrr();
< 
< 		expand("\001j", buf, &buf[sizeof buf - 1], e);
< 		mx = getmxrr(host, MAXMXHOSTS, buf);
< 		if (mx->mx_number < 0)
---
> 		expand("\001w", buf, &buf[sizeof(buf) - 1], e);
> 		rcode = EX_OK;
> #ifdef NAMED_BIND
> 		if (host[0] != '[')
455,475c387
< 			/*
< 			 * Map errors into standard values
< 			 */
< 			if (mx->mx_number == -1) {
< 				extern char *CurHostName;
< 
< 				rcode = EX_TEMPFAIL;
< 				errno = ENAMESER;
< 				CurHostName = host;
< 			}
< 			else if (mx->mx_number == -3) 
< 			  /*
< 			   * If there were no MX records, deliver normally
< 			   */
< 			   {
< 			     mx->mx_number = 1;
< 			     mx->mx_hosts[0] = host;
< 			     rcode = EX_OK;
< 			   }				
< 			else
< 				rcode = EX_UNAVAILABLE;
---
> 			Nmx = getmxrr(host, MxHosts, buf, &rcode);
478,493c390
< 			rcode = EX_OK;
< #else MXDOMAIN
< 		mx = &dummy_mx;
< 		mx->mx_number = 1;
< 		mx->mx_hosts[0] = host;
< 		rcode = EX_OK;
< #endif MXDOMAIN
< 		/* send the initial SMTP protocol */
< 		if (rcode == EX_OK)
< 			rcode = smtpinit(m, pv);
< #else	NeXT_MOD
< 		/* send the initial SMTP protocol */
< 		rcode = smtpinit(m, pv);
< #endif	NeXT_MOD
< 
< 		if (rcode == EX_OK)
---
> #endif
495,499c392,401
< 			/* send the recipient list */
< 			tobuf[0] = '\0';
< 			for (to = tochain; to != NULL; to = to->q_tchain)
< 			{
< 				int i;
---
> 			Nmx = 1;
> 			MxHosts[0] = host;
> 		}
> 		if (Nmx >= 0)
> 		{
> 			message(Arpa_Info, "Connecting to %s (%s)...",
> 			    MxHosts[0], m->m_name);
> 			if ((rcode = smtpinit(m, pv)) == EX_OK) {
> 				register char *t = tobuf;
> 				register int i;
501,506c403,414
< 				e->e_to = to->q_paddr;
< 				i = smtprcpt(to, m);
< 				if (i != EX_OK)
< 				{
< 					markfailure(e, to, i);
< 					giveresponse(i, m, e);
---
> 				/* send the recipient list */
> 				tobuf[0] = '\0';
> 				for (to = tochain; to; to = to->q_tchain) {
> 					e->e_to = to->q_paddr;
> 					if ((i = smtprcpt(to, m)) != EX_OK) {
> 						markfailure(e, to, i);
> 						giveresponse(i, m, e);
> 					}
> 					else {
> 						*t++ = ',';
> 						for (p = to->q_paddr; *p; *t++ = *p++);
> 					}
508,511c416,422
< 				else
< 				{
< 					(void) strcat(tobuf, ",");
< 					(void) strcat(tobuf, to->q_paddr);
---
> 
> 				/* now send the data */
> 				if (tobuf[0] == '\0')
> 					e->e_to = NULL;
> 				else {
> 					e->e_to = tobuf + 1;
> 					rcode = smtpdata(m, e);
513d423
< 			}
515,521c425,426
< 			/* now send the data */
< 			if (tobuf[0] == '\0')
< 				e->e_to = NULL;
< 			else
< 			{
< 				e->e_to = tobuf + 1;
< 				rcode = smtpdata(m, e);
---
> 				/* now close the connection */
> 				smtpquit(m);
523,525d427
< 
< 			/* now close the connection */
< 			smtpquit(m);
529c431,433
< # endif SMTP
---
> #endif /* SMTP */
> 	{
> 		message(Arpa_Info, "Connecting to %s (%s)...", host, m->m_name);
530a435,438
> 	}
> #ifdef NAMED_BIND
> 	_res.options |= RES_DEFNAMES | RES_DNSRCH;	/* XXX */
> #endif
542d449
< 	{
545,549d451
< #if	NeXT_MOD
< 	} else for (to = tochain; to != NULL; to = to->q_tchain) {
< 		markstats(e, to);
< #endif	NeXT_MOD
< 	}
579,582d480
< #if	NeXT_MOD
< 	else if (rcode != EX_TEMPFAIL && rcode != EX_OSERR && 
< 	         rcode !=EX_IOERR)
< #else	NeXT_MOD
584d481
< #endif	NeXT_MOD
684,687d580
< **	  NeXT_MOD:
< **		If exit status is -1, ExitStat and errno are set as from
< **		openmailer().
< **	  Otherwise:
690c583
< 
---
> static
708,710d600
< #if	NeXT_MOD
< 		return (EX_TEMPFAIL);
< #else	NeXT_MOD
712d601
< #endif	NeXT_MOD
754,789d642
< #if	NeXT_MOD
< char *enderr[] = {
< 	"Zero",
< 	"Hangup",
< 	"Interrupt",
< 	"Quit",
< 	"Illegal instruction",
< 	"Trace",
< 	"IOT",
< 	"EMT",
< 	"Floating point exception",
< 	"Kill",
< 	"Bus error",
< 	"Segmentation violation",
< 	"Bad argument to system call",
< 	"Broken pipe",
< 	"Alarm clock",
< 	"Software termination",
< 	"Urgent",
< 	"Stop",
< 	"Stop from keyboard",
< 	"Continue",
< 	"Child status",
< 	"Background read",
< 	"Background write",
< 	"I/O",
< 	"CPU time limit exceeded",
< 	"File size limit exceeded",
< 	"Virtual time alarm",
< 	"Profiling timer alarm",
< 	"Window change"
< } ;
< 
< #define MAXENDERR	(sizeof(enderr)/sizeof(enderr[0]))
< #endif	NeXT_MOD
< 
811,819d663
< #if	NeXT_MOD
< 		if (st < 0 || st >= MAXENDERR)
< 		    message(Arpa_Info,
< 			"%s delivery program died with signal %d", name, st);
< 		else
< 		    message(Arpa_Info,
< 			"%s delivery program died with %s signal", name, 
< 				enderr[st]);
< #else	NeXT_MOD
821d664
< #endif	NeXT_MOD
843c686
< **		-1 on error (with errno set appropriately if NeXT_MOD).
---
> **		-1 on error.
848d690
< **		sets errno if NeXT_MOD and if it returns -1.
865d706
< 	extern int DtableSize;		/* main.c -- from getdtablesize() */
867d707
< # ifdef DEBUG
873d712
< # endif DEBUG
876,877d714
< #if	NeXT_MOD
< #else	NeXT_MOD
879d715
< #endif	NeXT_MOD
890d725
< #ifdef DEBUG
898d732
< #endif DEBUG
900,932d733
< #if	NeXT_MOD
< 	if (strcmp(m->m_mailer, "[IPC]") == 0 ||
< 	    strcmp(m->m_mailer, "[TCP]") == 0)
< 	{
< #ifdef DAEMON
< 		register int i, j;
< 		register u_short port;
< 
< 		CurHostName = pvp[1];
< 		if (!clever || mx == NULL)
< 			syserr("non-clever TCP");
< 		if (pvp[2] != NULL)
< 			port = atoi(pvp[2]);
< 		else
< 			port = 0;
<  		for (j = 0; j < mx->mx_number; j++)
< 		{
< 			CurHostName = mx->mx_hosts[j];
< 			if (Verbose && !sameword(CurHostName, pvp[1]))
< 				printf("mail exchanger is %s\n", CurHostName);
< 			i = makeconnection(CurHostName, port, pmfile, prfile);
< 			if (i == EX_OK)
< 				return(0);
< 		}
< 		/* Note that errno is set for this case */
< 		ExitStat = i;
< 		return (-1);
< #else DAEMON
< 		syserr("openmailer: no TCP");
< 		return (-1);
< #endif DAEMON
< 	}
< #else	NeXT_MOD
940c741
< 		register int i;
---
> 		register int i, j;
949a751,753
> 		for (j = 0; j < Nmx; j++)
> 		{
> 			CurHostName = MxHosts[j];
952,959c756,768
< 		st = stab(pvp[1], ST_HOST, ST_FIND);
< 		if (st == NULL || st->s_host.ho_exitstat == EX_OK)
< 			i = makeconnection(pvp[1], port, pmfile, prfile);
< 		else
< 		{
< 			i = st->s_host.ho_exitstat;
< 			errno = st->s_host.ho_errno;
< 		}
---
> 			st = stab(MxHosts[j], ST_HOST, ST_FIND);
> 			if (st == NULL || st->s_host.ho_exitstat == EX_OK) {
> 				if (j > 1)
> 					message(Arpa_Info,
> 					    "Connecting to %s (%s)...",
> 					    MxHosts[j], m->m_name);
> 				i = makeconnection(MxHosts[j], port, pmfile, prfile);
> 			}
> 			else
> 			{
> 				i = st->s_host.ho_exitstat;
> 				errno = st->s_host.ho_errno;
> 			}
961c770
< 		i = makeconnection(pvp[1], port, pmfile, prfile);
---
> 			i = makeconnection(MxHosts[j], port, pmfile, prfile);
963,964c772,773
< 		if (i != EX_OK)
< 		{
---
> 			if (i != EX_OK)
> 			{
966,970c775,779
< 			/* enter status of this host */
< 			if (st == NULL)
< 				st = stab(pvp[1], ST_HOST, ST_ENTER);
< 			st->s_host.ho_exitstat = i;
< 			st->s_host.ho_errno = errno;
---
> 				/* enter status of this host */
> 				if (st == NULL)
> 					st = stab(MxHosts[j], ST_HOST, ST_ENTER);
> 				st->s_host.ho_exitstat = i;
> 				st->s_host.ho_errno = errno;
972,973c781,785
< 			ExitStat = i;
< 			return (-1);
---
> 				ExitStat = i;
> 				continue;
> 			}
> 			else
> 				return (0);
975,976c787
< 		else
< 			return (0);
---
> 		return (-1);
982d792
< #endif	NeXT_MOD
991,1001d800
< #if	NeXT_MOD
< 	if (mpvect[0] <= 2 || mpvect[1] <= 2)
< 	{
< 		if (pipe(mpvect) < 0)
< 		{
< 			syserr("openmailer: pipe (to mailer)");
< 			return (-1);
< 		}
< 	}
< #endif	NeXT_MOD
< 
1046a846
> 		extern int DtableSize;
1095,1100c895,899
< 		for (i = 3; i < DtableSize; i++)
< #ifdef FIOCLEX
< 			(void) ioctl(i, FIOCLEX, 0);
< #else FIOCLEX
< 			(void) close(i);
< #endif FIOCLEX
---
> 		for (i = 3; i < DtableSize; i++) {
> 			register int j;
> 			if ((j = fcntl(i, F_GETFD, 0)) != -1)
> 				(void)fcntl(i, F_SETFD, j|1);
> 		}
1103,1105d901
< #if	NeXT_MOD
< 		execv(m->m_mailer, pvp);
< #else	NeXT_MOD
1107,1109d902
< #endif	NeXT_MOD
< 
< #ifdef FIOCLEX
1111,1126d903
< #else FIOCLEX
< 		printf("Cannot exec '%s' errno=%d\n", m->m_mailer, errno);
< 		(void) fflush(stdout);
< #endif FIOCLEX
< #if	NeXT_MOD
< 	 	switch (errno)
< 		  {
< 		    case EIO:
< 		    case EAGAIN:
< 		    case ENOMEM:
< 		    case EPROCLIM:
< 			_exit(EX_TEMPFAIL);
< 		    default:
< 			_exit(EX_UNAVAILABLE);
< 		  }
< #else	NeXT_MOD
1132d908
< #endif	NeXT_MOD
1177c953
< 	extern int N_SysEx;
---
> 	extern int N_SysEx, h_errno;
1199d974
< #if	NeXT_MOD
1201,1223d975
< 		extern char SmtpError[];
< 
< 		if (AlreadyKnown)
< 			(void) strcpy(buf, "250 Skipped");
< 		else 
< 			(void) strcpy(buf, SysExMsg[i]);
< 		if (SmtpError[0] != '\0' && 
< 			(errno == 0 || errno == ECONNRESET) )
< 		{
< 				(void) strcat(buf, ": ");
< 				(void) strcat(buf, SmtpError);
< 		}
< 		else if (errno)
< 		{
< 			extern char *errstring();
< 
< 			(void) strcat(buf, ": ");
< 			(void) strcat(buf, errstring(errno));
< 		}
< 		statmsg = buf;
< 	}
< #else	NeXT_MOD
< 	{
1257d1008
< #endif	NeXT_MOD
1265,1266d1015
< 	** Note the "%s" is needed to prevent percent signs in recipient
< 	** names from being treated as formatting commands (NeXT_MOD).
1270,1272d1018
< #if	NeXT_MOD
< 		message(Arpa_Info, "%s", &statmsg[4]);
< #else	NeXT_MOD
1274d1019
< #endif	NeXT_MOD
1285,1286c1030
< 	**	that.  Save the new envelope message unless it is temporary
< 	**	and we already have a permanent error (NeXT_MOD).
---
> 	**	that.
1294,1297d1037
< #if	NeXT_MOD
< 	if (stat != EX_OK && (stat != EX_TEMPFAIL ||
< 		 !bitset(EF_TIMEOUT|EF_FATALERRS, e->e_flags)))
< #else	NeXT_MOD
1299d1038
< #endif	NeXT_MOD
1306,1307d1044
< #if	NeXT_MOD
< #else	NeXT_MOD
1309d1045
< #endif	NeXT_MOD
1330,1333d1065
< #ifdef	NeXT_NFS
< 	if (!AlreadyKnown)
< 	    syslog(LOG_INFO, "%s: to=%s, delay=%s, stat=%s", CurEnv->e_id,
< #else	NeXT_NFS
1335d1066
< #endif	NeXT_NFS
1337d1067
< 
1494,1498d1223
< #ifdef	NeXT_NFS
< # ifdef SIGCHLD
< 	(void) signal(SIGCHLD, SIG_DFL);
< # endif SIGCHLD
< #endif	NeXT_NFS
1590,1592d1314
< #ifdef	NeXT_NFS
< 	int checkpointCount;
< #else	NeXT_NFS
1603d1324
< #endif	NeXT_NFS
1605d1325
< #ifdef DEBUG
1611d1330
< #endif DEBUG
1623,1626d1341
< #ifdef	NeXT_NFS
< 		e->e_to = e->e_sendqueue->q_paddr;
< 		message(Arpa_Usrerr,"Mail loop detected");
< #endif	NeXT_NFS
1639,1643d1353
< #ifdef	NeXT_NFS
< 	if (SendMode == SM_VERIFY)
< 	  {
< 	    mode = SM_VERIFY;
< 	  }
1645,1689d1354
< 	else if (!bitset(EF_INQUEUE, e->e_flags))
< 	      {
< 		  /*
< 		   * Add in extra penalty points for messages to lots of
< 		   * recipients (like big mailing lists).
< 		   */
< 	    	checkpointCount = 0;
< 		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
< 		  {
< 		     if (!bitset(QDONTSEND, q->q_flags)) checkpointCount++;
< 		  }
< 		e->e_msgpriority += WKRECIPFACT*checkpointCount;
< 		  /*
< 		   * Determine actual delivery mode: 
< 		   * if we are over the threshold and the message is too "big"
< 		   * then we just queue it up.
< 		   * If message is too "small" then complain.
< 		   * Messages with no recipients are an error.
< 		   */
< 		if (RecipThreshold > 0 &&
< 		    checkpointCount > RecipThreshold &&
< 		    e->e_bodysize < REJECT_MIN)
< 		    {
< 		      syserr("Too many recipients for no message body");
< 		      return;
< 		    }
< 		if (checkpointCount == 0 && !ForceMail) 
< 		  {
< 		    e->e_to = e->e_sendqueue->q_paddr;
< 		    message(Arpa_Usrerr,"Possible alias loop");
< 		    syserr("No valid recipients");
< 		    return;
< 		  }
< 		if (mode == SM_DEFAULT)
< 		  {
< 		    if (shouldqueue(e->e_msgpriority))
< 				mode = SM_QUEUE;
< 			else
< 				mode = SendMode;
< 		  }
< 		queueup(e, TRUE, mode == SM_QUEUE);
< 	      }
< #endif QUEUE
< #else	NeXT_NFS
< # ifdef QUEUE
1695d1359
< #endif	NeXT_NFS
1748,1759d1411
< #ifdef	NeXT_NFS
< 		/*
< 		 * Checkpoint the queue every once in a while,
< 		 * so we don't get a lot of duplicate messages
< 		 * if we crash during delivery of a big list.
< 		 */
< 		if (++checkpointCount >= CheckPointLimit)
< 		  {
< 		    checkpoint(e,q->q_next);
< 		    checkpointCount = 0;
< 		  }
< #endif	NeXT_NFS
1774d1425
< # ifdef DEBUG
1780d1430
< # endif DEBUG
1783,1785d1432
< #ifdef	NeXT_NFS
< 		if (!bitset(QBADADDR|QQUEUEUP, q->q_flags))
< #else	NeXT_NFS
1787d1433
< #endif	NeXT_NFS
1809d1454
< # ifdef DEBUG
1812d1456
< # endif DEBUG
1820,1821d1463
< #ifdef	NeXT_NFS
< #else	NeXT_NFS
1825d1466
< #endif	NeXT_NFS
diff -r sendmail.target/src/domain.c sendmail/src/domain.c
1d0
< /* @(#)domain.c	1.2 87/09/08 3.2/4.3NFSSRC */
3,12c2,17
< **  Sendmail
< **  Copyright (c) 1986  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1986 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
< # include <sys/param.h>
< # include "sendmail.h"
---
>  * Copyright (c) 1986 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
14,15c19
< #ifdef MXDOMAIN
< SCCSID(@(#)domain.c 1.5 87/06/26 SMI); /* from UCB 5.3 7/21/86 */
---
> #include <sendmail.h>
17,25c21,25
< #if	NeXT_MOD
< #include <sys/errno.h>
< #endif	NeXT_MOD
< # include <arpa/nameser.h>
< # include <resolv.h>
< # include <netdb.h>
< 
< #ifdef NeXT_MOD
< #define getshort res_getshort
---
> #ifndef lint
> #ifdef NAMED_BIND
> static char sccsid[] = "@(#)domain.c	5.19 (Berkeley) 1/1/89 (with name server)";
> #else
> static char sccsid[] = "@(#)domain.c	5.19 (Berkeley) 1/1/89 (without name server)";
26a27
> #endif /* not lint */
27a29,36
> #ifdef NAMED_BIND
> 
> #include <sys/param.h>
> #include <errno.h>
> #include <arpa/nameser.h>
> #include <resolv.h>
> #include <netdb.h>
> 
33c42
< static char hostbuf[BUFSIZ];
---
> static char hostbuf[MAXMXHOSTS*PACKETSZ];
35,55c44,46
< #if	NeXT_MOD
< extern int h_errno;
< extern int errno;
< #else	NeXT_MOD
< int h_errno;
< #endif	NeXT_MOD
< 
< /*
<  * Look up Mail Exchanger records, first in cache, then to name server.
<  * return values for mx->mx_number:
<  *	-3 hard host not found
<  *	-2 hard error looking up MX record
<  *	-1 server fail, try again
<  *	 0
<  *	 1 TOPS-20 FORMERR kludge, or no records but valid name
<  *	   or we are the first record
<  */
< struct mxinfo *getmxrr(host, maxmx, localhost)
< 	char *host;
< 	int maxmx;
< 	char *localhost;
---
> getmxrr(host, mxhosts, localhost, rcode)
> 	char *host, **mxhosts, *localhost;
> 	int *rcode;
57c48,51
< 
---
> 	extern int h_errno;
> 	register u_char *eom, *cp;
> 	register int i, j, n, nmx;
> 	register char *bp;
59,71c53,55
< 	char *eom, *bp, *cp;
< 	querybuf buf, answer;
< 	int n, n1, i, j, nmx, ancount, qdcount, buflen;
< 	int seenlocal;
< 	u_short prefer[BUFSIZ];
< 	u_short pref, localpref, type, class;
< 	STAB *st;
< 	register struct mxinfo *mx;
< 	
< #ifdef DEBUG
< 	if (tTd(8, 2)) 
< 		_res.options |= RES_DEBUG;
< #endif
---
> 	querybuf answer;
> 	int ancount, qdcount, buflen, seenlocal;
> 	u_short pref, localpref, type, prefer[MAXMXHOSTS];
73,84c57,69
< 	st = stab(host, ST_MX, ST_FIND);
< 	if (st != NULL) {
< 	    /*
< 	     * found in the cache, just return it.
< 	     */
< 	     mx = &st->s_value.sv_mxinfo;
< 	     AlreadyKnown = (mx->mx_number == -1);
< 	     return(mx);
< 	}
< 	AlreadyKnown = FALSE;
< 	st = stab(host, ST_MX, ST_ENTER);
< 	mx = &st->s_value.sv_mxinfo;
---
> 	errno = 0;
> 	n = res_search(host, C_IN, T_MX, (char *)&answer, sizeof(answer));
> 	if (n < 0)
> 	{
> 		if (tTd(8, 1))
> 			printf("getmxrr: res_search failed (errno=%d, h_errno=%d)\n",
> 			    errno, h_errno);
> 		switch (h_errno)
> 		{
> 		  case NO_DATA:
> 		  case NO_RECOVERY:
> 			/* no MX data on this host */
> 			goto punt;
86,104c71,83
< 	n = res_mkquery(QUERY, host, C_IN, T_MX, (char *)NULL, 0, NULL,
< 		(char *)&buf, sizeof(buf));
< 	if (n < 0) {
< #ifdef DEBUG
< 		if (tTd(8, 1) || _res.options & RES_DEBUG)
< 			printf("res_mkquery failed\n");
< #endif
< 		h_errno = NO_RECOVERY;
< 		mx->mx_number = -2;
< 		return(mx);
< 	}
< 	n = res_send((char *)&buf, n, (char *)&answer, sizeof(answer));
< 	if (n < 0) {
< #ifdef DEBUG
< #if	NeXT_MOD
< 		if (tTd(8, 1) || _res.options & RES_DEBUG) {
< 			int terrno = errno;
< 			printf("res_send failed\n");
< 			errno = terrno;
---
> 		  case HOST_NOT_FOUND:
> 			/* the host just doesn't exist */
> 			*rcode = EX_NOHOST;
> 			break;
> 
> 		  case TRY_AGAIN:
> 			/* couldn't connect to the name server */
> 			if (!UseNameServer && errno == ECONNREFUSED)
> 				goto punt;
> 
> 			/* it might come up later; better queue it up */
> 			*rcode = EX_TEMPFAIL;
> 			break;
106,128c85,87
< #else	NeXT_MOD
< 		if (tTd(8, 1) || _res.options & RES_DEBUG)
< 			printf("res_send failed\n");
< #endif	NeXT_MOD
< #endif
< #if	NeXT_MOD
< 		if (errno == ECONNREFUSED) {
< 			/*
< 			 * No domain name server there.  We'll assume
< 			 * that the resolver has not been configured
< 			 * and we will leave the hostname unchanged.
< 			 */
< 			h_errno = HOST_NOT_FOUND;
< 			mx->mx_number = -3;
< 		} else {
< 			h_errno = TRY_AGAIN;
< 			mx->mx_number = -1;
< 		}
< #else	NeXT_MOD
< 		h_errno = TRY_AGAIN;
< 		mx->mx_number = -1;
< #endif	NeXT_MOD
< 		return(mx);
---
> 
> 		/* irreconcilable differences */
> 		return (-1);
130,183c89,96
< 	eom = (char *)&answer + n;
< 	/*
< 	 * find first satisfactory answer
< 	 */
< 	hp = (HEADER *) &answer;
< 	ancount = ntohs(hp->ancount);
< 	qdcount = ntohs(hp->qdcount);
< 	if (hp->rcode != NOERROR || ancount == 0) {
< #ifdef DEBUG
< 		if (tTd(8, 1) || _res.options & RES_DEBUG)
< 			printf("rcode = %d, ancount=%d\n", hp->rcode, ancount);
< #endif
< 		switch (hp->rcode) {
< 			case NXDOMAIN:
< 				/* Check if it's an authoritive answer */
< 				if (hp->aa) {
< 					h_errno = HOST_NOT_FOUND;
< 					mx->mx_number = -3;
< 				} else {
< 					h_errno = TRY_AGAIN;
< 					mx->mx_number = -1;
< 				}
< 				return(mx);
< 			case SERVFAIL:
< 				h_errno = TRY_AGAIN;
< 				mx->mx_number = -1;
< 				return(mx);
< # define OLDJEEVES
< #ifdef OLDJEEVES
< 			/*
< 			 * Jeeves (TOPS-20 server) still does not
< 			 * support MX records.  For the time being,
< 			 * we must accept FORMERRs as the same as
< 			 * NOERROR.
< 			 */
< 			case FORMERR:
< #endif OLDJEEVES
< 			case NOERROR:
< 				mx->mx_hosts[0] = newstr(host);
< 				mx->mx_number = 1;
< 				return(mx);
< #ifndef OLDJEEVES
< 			case FORMERR:
< #endif OLDJEEVES
< 			case NOTIMP:
< 			case REFUSED:
< 				h_errno = NO_RECOVERY;
< 				mx->mx_number = -2;
< 				return(mx);
< 		}
< 		mx->mx_number = -1;
< 		return(mx);
< 	}
< 	bp = hostbuf;
---
> 
> 	/* find first satisfactory answer */
> 	hp = (HEADER *)&answer;
> 	cp = (u_char *)&answer + sizeof(HEADER);
> 	eom = (u_char *)&answer + n;
> 	for (qdcount = ntohs(hp->qdcount); qdcount--; cp += n + QFIXEDSZ)
> 		if ((n = dn_skipname(cp, eom)) < 0)
> 			goto punt;
187,193c100,102
< 	cp = (char *)&answer + sizeof(HEADER);
< 	if (qdcount) {
< 		cp += dn_skip(cp) + QFIXEDSZ;
< 		while (--qdcount > 0)
< 			cp += dn_skip(cp) + QFIXEDSZ;
< 	}
< 	while (--ancount >= 0 && cp < eom && nmx < maxmx) {
---
> 	bp = hostbuf;
> 	ancount = ntohs(hp->ancount);
> 	while (--ancount >= 0 && cp < eom && nmx < MAXMXHOSTS) {
197,201c106
< 		type = getshort(cp);
<  		cp += sizeof(u_short);
< 		/*
< 		class = getshort(cp);
< 		*/
---
> 		GETSHORT(type, cp);
203,204c108
< 		n = getshort(cp);
< 		cp += sizeof(u_short);
---
> 		GETSHORT(n, cp);
206d109
< #ifdef DEBUG
209,210c112
< 					type, n);
< #endif
---
> 				    type, n);
214,215c116
< 		pref = getshort(cp);
< 		cp += sizeof(u_short);
---
> 		GETSHORT(pref, cp);
219,220c120,122
< 		if (sameword(bp, localhost))
< 		{
---
> 		if (!strcasecmp(bp, localhost)) {
> 			if (seenlocal == 0 || pref < localpref)
> 				localpref = pref;
222d123
< 			localpref = pref;
226,229c127,130
< 		mx->mx_hosts[nmx++] = newstr(bp);
< 		n1 = strlen(bp)+1;
< 		bp += n1;
< 		buflen -= n1;
---
> 		mxhosts[nmx++] = bp;
> 		n = strlen(bp) + 1;
> 		bp += n;
> 		buflen -= n;
231,281d131
< 	  /*
< 	   * Scan the response for useful additional records, too.
< 	   * Normally these will be address records for the forwarder,
< 	   * or the host itself (if there are no MX records).
< 	   */
< 	for (ancount = ntohs(hp->arcount);
< 	   --ancount >= 0 && cp < eom; cp += n) {
< 		struct in_addr sin, *addlist;
< 
< 		if ((n = dn_expand((char *)&answer, eom, cp, bp, buflen)) < 0)
< 			break;
< 		cp += n;
< 		type = getshort(cp);
<  		cp += sizeof(u_short);
< 		class = getshort(cp);
<  		cp += sizeof(u_short) + sizeof(u_long);
< 		n = getshort(cp);
< 		cp += sizeof(u_short);
< 		if (type != T_A || class != C_IN)  {
< #ifdef DEBUG
< 			if (tTd(8, 1) || _res.options & RES_DEBUG)
< 				printf("unexpected add. type %d, size %d\n",
< 					type, n);
< #endif
< 			continue;
< 		}
< 		(void) bcopy(cp, &sin, n);
< 		st = stab(bp, ST_HOST, ST_FIND);
< 		if (st == NULL) {
< 		    /*
< 		     * not found in the cache, add it.
< 		     */
< 		    st = stab(bp, ST_HOST, ST_ENTER);
< 		    if (st == NULL)
< 			continue;
< 		    st->s_value.sv_host.h_addrlist[0].s_addr = INADDR_ANY;
< 		    st->s_value.sv_host.h_down = 0;
< 		}
< 		st->s_value.sv_host.h_valid = 1;
< 		st->s_value.sv_host.h_exists = 1;
< 		addlist = st->s_value.sv_host.h_addrlist;
< 		while (addlist->s_addr != INADDR_ANY) {
< 		    if (addlist->s_addr == sin.s_addr)
< 			break;
< 		    addlist++;
< 		}
< 		if (addlist->s_addr == INADDR_ANY) {
< 		    addlist++->s_addr = sin.s_addr;
< 		    addlist->s_addr = INADDR_ANY;
< 		}
< 	}
283,285c133,134
< 		mx->mx_hosts[0] = newstr(host);
< 		mx->mx_number = 1;
< 		return(mx);
---
> punt:		mxhosts[0] = strcpy(hostbuf, host);
> 		return(1);
286a136
> 
290,292c140,143
< 			if (prefer[i] > prefer[j]) {
< 				int temp;
< 				char *temp1;
---
> 			if (prefer[i] > prefer[j] ||
> 			    (prefer[i] == prefer[j] && rand() % 1 == 0)) {
> 				register int temp;
> 				register char *temp1;
297,299c148,150
< 				temp1 = mx->mx_hosts[i];
< 				mx->mx_hosts[i] = mx->mx_hosts[j];
< 				mx->mx_hosts[j] = temp1;
---
> 				temp1 = mxhosts[i];
> 				mxhosts[i] = mxhosts[j];
> 				mxhosts[j] = temp1;
302,304c153
< 		if (seenlocal && (prefer[i] >= localpref))
< 		{
< 			nmx = i;
---
> 		if (seenlocal && prefer[i] >= localpref) {
306,307c155,157
< 			 * We are the first MX, might as well try delivering
< 			 * since nobody is supposed to have more info.
---
> 			 * truncate higher pref part of list; if we're
> 			 * the best choice left, we should have realized
> 			 * awhile ago that this was a local delivery.
309,313c159,161
< 			if (nmx == 0)
< 			{
< 				mx->mx_hosts[0] = newstr(host);
< 				mx->mx_number = 1;
< 				return(mx);
---
> 			if (i == 0) {
> 				*rcode = EX_CONFIG;
> 				return(-1);
314a163
> 			nmx = i;
318,319c167
< 	mx->mx_number = nmx;
< 	return(mx);
---
> 	return(nmx);
322d169
< 
327c174,175
< 
---
> 	register u_char *eom, *cp;
> 	register int n; 
329,331c177
< 	char *eom, *cp;
< 	querybuf buf, answer;
< 	int n, ancount, qdcount;
---
> 	querybuf answer;
333,334c179,180
< 	char nbuf[BUFSIZ];
< 	int first;
---
> 	int first, ancount, qdcount, loopcnt;
> 	char nbuf[PACKETSZ];
336,337c182,196
< 	n = res_mkquery(QUERY, host, C_IN, T_ANY, (char *)NULL, 0, NULL,
< 		(char *)&buf, sizeof(buf));
---
> 	loopcnt = 0;
> loop:
> 	/*
> 	 * Use query type of ANY if possible (NO_WILDCARD_MX), which will
> 	 * find types CNAME, A, and MX, and will cause all existing records
> 	 * to be cached by our local server.  If there is (might be) a
> 	 * wildcard MX record in the local domain or its parents that are
> 	 * searched, we can't use ANY; it would cause fully-qualified names
> 	 * to match as names in a local domain.
> 	 */
> # ifdef NO_WILDCARD_MX
> 	n = res_search(host, C_IN, T_ANY, (char *)&answer, sizeof(answer));
> # else
> 	n = res_search(host, C_IN, T_CNAME, (char *)&answer, sizeof(answer));
> # endif
339,343c198,200
< #ifdef DEBUG
< 		if (tTd(8, 1) || _res.options & RES_DEBUG)
< 			printf("res_mkquery failed\n");
< #endif
< 		h_errno = NO_RECOVERY;
---
> 		if (tTd(8, 1))
> 			printf("getcanonname:  res_search failed (errno=%d, h_errno=%d)\n",
> 			    errno, h_errno);
346,380c203,205
< 	n = res_send((char *)&buf, n, (char *)&answer, sizeof(answer));
< 	if (n < 0) {
< #ifdef DEBUG
< #if	NeXT_MOD
< 		if (tTd(8, 1) || _res.options & RES_DEBUG) {
< 			int terrno = errno;
< 			printf("res_send failed\n");
< 			errno = terrno;
< 		}
< #else	NeXT_MOD
< 		if (tTd(8, 1) || _res.options & RES_DEBUG)
< 			printf("res_send failed\n");
< #endif	NeXT_MOD
< #endif
< #if	NeXT_MOD
< 		if (errno == ECONNREFUSED) {
< 			/*
< 			 * No domain name server there.  We'll assume
< 			 * that the resolver has not been configured
< 			 * and we will leave the hostname unchanged.
< 			 */
< 			h_errno = HOST_NOT_FOUND;
< 		} else {
< 			h_errno = TRY_AGAIN;
< 		}
< #else	NeXT_MOD
< 		h_errno = TRY_AGAIN;
< #endif	NeXT_MOD
< 		return;
< 	}
< 	eom = (char *)&answer + n;
< 	/*
< 	 * find first satisfactory answer
< 	 */
< 	hp = (HEADER *) &answer;
---
> 
> 	/* find first satisfactory answer */
> 	hp = (HEADER *)&answer;
382,385c207,208
< 	qdcount = ntohs(hp->qdcount);
< 	/*
< 	 * We don't care about errors here, only if we got an answer
< 	 */
---
> 
> 	/* we don't care about errors here, only if we got an answer */
387,388c210
< #ifdef DEBUG
< 		if (tTd(8, 1) || _res.options & RES_DEBUG)
---
> 		if (tTd(8, 1))
390d211
< #endif
393,400c214,225
< 	cp = (char *)&answer + sizeof(HEADER);
< 	if (qdcount) {
< 		cp += dn_skip(cp) + QFIXEDSZ;
< 		while (--qdcount > 0)
< 			cp += dn_skip(cp) + QFIXEDSZ;
< 	}
< 	first = 1;
< 	while (--ancount >= 0 && cp < eom) {
---
> 	cp = (u_char *)&answer + sizeof(HEADER);
> 	eom = (u_char *)&answer + n;
> 	for (qdcount = ntohs(hp->qdcount); qdcount--; cp += n + QFIXEDSZ)
> 		if ((n = dn_skipname(cp, eom)) < 0)
> 			return;
> 
> 	/*
> 	 * just in case someone puts a CNAME record after another record,
> 	 * check all records for CNAME; otherwise, just take the first
> 	 * name found.
> 	 */
> 	for (first = 1; --ancount >= 0 && cp < eom; cp += n) {
404c229
< 		if (first) {
---
> 		if (first) {			/* XXX */
410,411c235
< 		type = getshort(cp);
<  		cp += sizeof(u_short);
---
> 		GETSHORT(type, cp);
413,414c237
< 		n = getshort(cp);
< 		cp += sizeof(u_short);
---
> 		GETSHORT(n, cp);
417,418c240,242
< 			 * Assume that only one cname will be found.  More
< 			 * than one is undefined.
---
> 			 * assume that only one cname will be found.  More
> 			 * than one is undefined.  Copy so that if dn_expand
> 			 * fails, `host' is still okay.
423c247
< 			(void)strncpy(host, nbuf, hbsize);
---
> 			(void)strncpy(host, nbuf, hbsize); /* XXX */
425,426c249,251
< 			getcanonname(host, hbsize);
< 			break;
---
> 			if (++loopcnt > 8)	/* never be more than 1 */
> 				return;
> 			goto loop;
428d252
< 		cp += n;
430d253
< 	return;
432c255,276
< #endif MXDOMAIN
---
> 
> #else /* not NAMED_BIND */
> 
> #include <netdb.h>
> 
> getcanonname(host, hbsize)
> 	char *host;
> 	int hbsize;
> {
> 	struct hostent *hp;
> 
> 	hp = gethostbyname(host);
> 	if (hp == NULL)
> 		return;
> 
> 	if (strlen(hp->h_name) >= hbsize)
> 		return;
> 
> 	(void) strcpy(host, hp->h_name);
> }
> 
> #endif /* not NAMED_BIND */
diff -r sendmail.target/src/envelope.c sendmail/src/envelope.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)envelope.c	5.12 (Berkeley) 12/17/85";
< #endif not lint
---
> static char sccsid[] = "@(#)envelope.c	5.18 (Berkeley) 1/1/89";
> #endif /* not lint */
81,103d88
< #if	NeXT_MOD
< 	/*
< 	**  If called from Eric Schmidt's network, do special mailback.
< 	**	Fundamentally, this is the mailback case except that
< 	**	it returns an OK exit status (assuming the return
< 	**	worked).
< 	**  If the from address is not local, mail it back.
< 	**      In this case also, don't confuse the poor network mailer
< 	**	(eg rmail) by returning a bad exit status.  If we "handled" the
< 	**	error by mailing a response, tell our caller that it need not
< 	**	also handle the problem.
< 	*/
< 
< 	if (ErrorMode == EM_BERKNET ||
< 		(e->e_from.q_mailer &&
< 		 !bitnset(M_LOCAL, e->e_from.q_mailer->m_flags)))
< 	{
< 		ExitStat = EX_OK;
< 		ErrorMode = EM_MAIL;
< 	}
< 
< #endif	NeXT_MOD
< #ifdef DEBUG
110d94
< #endif DEBUG
446d429
< # ifdef DEBUG
449d431
< # endif DEBUG
463,465d444
< #if	NeXT_MOD
< 		errno = 0;
< #endif	NeXT_MOD
476,479c455
< 		if (!trusteduser(realname) &&
< # ifdef DEBUG
< 		    (!tTd(1, 9) || getuid() != geteuid()) &&
< # endif DEBUG
---
> 		if (!trusteduser(realname) && getuid() != geteuid() &&
496,497c472,479
< 				syslog(LOG_ERR, "Unparseable user %s wants to be %s",
< 						realname, from);
---
> 			    if (realname == from && RealHostName != NULL)
> 				syslog(LOG_NOTICE,
> 				    "from=%s unparseable, received from %s",
> 				    from, RealHostName);
> 			    else
> 				syslog(LOG_NOTICE,
> 				    "Unparseable username %s wants from=%s",
> 				    realname, from);
513,517d494
< #if	NeXT_MOD
< 	if ((CurEnv->e_from.q_mailer == LocalMailer ||
< 	     bitnset(M_LOCAL, CurEnv->e_from.q_mailer->m_flags)) &&
< 	    (pw = getpwnam(CurEnv->e_from.q_user)) != NULL)
< #else	NeXT_MOD
520d496
< #endif	NeXT_MOD
554d529
< #ifndef V6
557d531
< #endif V6
576c550,554
< 		syserr("cannot prescan from (%s)", from);
---
> # ifdef LOG
> 		if (LogLevel >= 1)
> 			syslog(LOG_NOTICE, "cannot prescan from (%s)", from);
> # endif
> 		usrerr("cannot prescan from (%s)", from);
581,582d558
< #if	NeXT_MOD
< #else	NeXT_MOD
586d561
< #endif	NeXT_MOD
594,613d568
< #if	NeXT_MOD
< 		extern char *rindex();
< 		register char **p = pvp;
< 
< 		while (*p != NULL && strcmp(*p, "@") != 0)
< 			p++;
< 		if (*p != NULL)
< 			CurEnv->e_fromdomain = copyplist(p, TRUE);
< # ifdef DEBUG
< 		if (tTd(45, 1))
< 		{
< 			printf("fromdomain=");
< 			printav(CurEnv->e_fromdomain);
< 		}
< # endif DEBUG
< 	}
< 	rewrite(pvp, 4);
< 	cataddr(pvp, buf, sizeof buf);
< 	define('f', newstr(buf), CurEnv);
< #else	NeXT_MOD
619d573
< #endif	NeXT_MOD
diff -r sendmail.target/src/err.c sendmail/src/err.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)err.c	5.7 (Berkeley) 11/22/85";
< #endif not lint
---
> static char sccsid[] = "@(#)err.c	5.9 (Berkeley) 6/30/88";
> #endif /* not lint */
17,18d24
< #if	NeXT_MOD
< #else	NeXT_MOD
20d25
< #endif	NeXT_MOD
22,23d26
< static fmtmsg();
< 
362,367d364
< #if	NeXT_MOD
< 	  case ENAMESER:
< 		if (CurHostName == NULL)
< 			break;
< 		(void) sprintf(buf, "Name Server Failure for %s", CurHostName);
< #else	NeXT_MOD
370d366
< #endif	NeXT_MOD
diff -r sendmail.target/src/headers.c sendmail/src/headers.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)headers.c	5.7 (Berkeley) 9/21/85";
< #endif not lint
---
> static char sccsid[] = "@(#)headers.c	5.13 (Berkeley) 1/1/89";
> #endif /* not lint */
49d56
< # ifdef DEBUG
52d58
< # endif DEBUG
70c76
< 			syserr("chompheader: syntax error, line \"%s\"", line);
---
> 			usrerr("chompheader: syntax error, line \"%s\"", line);
284d289
< #ifdef DEBUG
287d291
< #endif DEBUG
290d293
< #ifdef DEBUG
295d297
< #endif DEBUG
325d326
< #ifdef DEBUG
328d328
< #endif DEBUG
391,393c391,403
< 		syslog(LOG_INFO, "%s: from=%s, size=%ld, class=%d\n",
< 		       CurEnv->e_id, CurEnv->e_from.q_paddr, CurEnv->e_msgsize,
< 		       CurEnv->e_class);
---
> 		char hbuf[100], *name = hbuf;
> 
> 		if (RealHostName == NULL)
> 			name = "local";
> 		else if (RealHostName[0] == '[')
> 			name = RealHostName;
> 		else
> 			(void)sprintf(hbuf, "%.90s (%s)", 
> 			    RealHostName, inet_ntoa(RealHostAddr.sin_addr));
> 		syslog(LOG_INFO,
> 		    "%s: from=%s, size=%ld, class=%d, received from %s\n",
> 		    CurEnv->e_id, CurEnv->e_from.q_paddr, CurEnv->e_msgsize,
> 		    CurEnv->e_class, name);
414d423
< 	extern bool sameword();
418c427
< 		if (sameword(p, Priorities[i].pri_name))
---
> 		if (!strcasecmp(p, Priorities[i].pri_name))
470d478
< # ifdef DEBUG
473d480
< # endif DEBUG
592d598
< # ifdef DEBUG
595d600
< # endif DEBUG
641,649d645
< #if	NeXT_MOD
< 			if (bitset(H_ERRSTO, h->h_flags))
< 			{
< 			  errors_to(h, e);
< 			  if (h->h_value && h->h_value[0])
< 			      commaize(h, h->h_value, fp, FALSE, m);
< 			  continue;
< 			}
< #endif	NeXT_MOD
721d716
< # ifdef DEBUG
724d718
< # endif DEBUG
854,886d847
< 
< #ifdef	NeXT_MOD
< /*
<  * create a default Errors-to: line if there is none yet
<  * But we DO have something in the error queue (e.g. a list owner)
<  */
< errors_to(h, e)
<     register HDR *h;
<     register ENVELOPE *e;
< {
<    char buf[1024];
<    ADDRESS *q;
<    register char *p;
<    bool another = FALSE;
< 
<   if (bitset(EF_ERRSTOFROM, e->e_flags) || e->e_errorqueue == NULL)
<   	return;
<   if (h->h_value && h->h_value[0])
<         return;
<   p = buf;
<   p[0] = '\0';
<   for (q = e->e_errorqueue;q;q = q->q_next)
<   {
< 	if (bitset(QDONTSEND|QBADADDR, q->q_flags))
< 		continue;
< 	if (another)
< 	    	(void) strcat(p, ", ");
< 	(void) strcat(p, q->q_paddr);
< 	another = TRUE;
<   }
<   h->h_value = newstr(p);
< }
< #endif	NeXT_MOD
diff -r sendmail.target/src/macro.c sendmail/src/macro.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)macro.c	5.3 (Berkeley) 9/19/85";
< #endif not lint
---
> static char sccsid[] = "@(#)macro.c	5.6 (Berkeley) 1/1/89";
> #endif /* not lint */
48d55
< # ifdef DEBUG
55d61
< # endif DEBUG
115d120
< # ifdef DEBUG
122d126
< # endif DEBUG
203d206
< # ifdef DEBUG
210d212
< # endif DEBUG
diff -r sendmail.target/src/mailstats.h sendmail/src/mailstats.h
2,12c2,19
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< **
< **	"@(#)mailstats.h	5.1 (Berkeley) 5/2/86";
< **
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  *
>  *	@(#)mailstats.h	5.3 (Berkeley) 6/30/88
>  */
17,19d23
< #if	NeXT_MOD
< # define NAMELEN 16	/* length of each mailer name */
< #endif	NeXT_MOD
29,32d32
< #if	NeXT_MOD
< 	char 	stat_names[MAXMAILERS][NAMELEN];
< 					/* symbolic names of mailers */
< #endif	NeXT_MOD
diff -r sendmail.target/src/main.c sendmail/src/main.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
13c21
< "@(#) Copyright (c) 1980 Regents of the University of California.\n\
---
> "@(#) Copyright (c) 1988 Regents of the University of California.\n\
15c23
< #endif not lint
---
> #endif /* not lint */
18,19c26,27
< static char	SccsId[] = "@(#)main.c	5.11 (Berkeley) 1/30/86";
< #endif not lint
---
> static char sccsid[] = "@(#)main.c	5.26 (Berkeley) 1/24/89";
> #endif /* not lint */
21,28c29
< # define  _DEFINE
< # include <signal.h>
< #if	NeXT_MOD
< # include <sys/ioctl.h>
< #else	NeXT_MOD
< # include <sgtty.h>
< #endif	NeXT_MOD
< # include "sendmail.h"
---
> #define	_DEFINE
29a31,37
> #include <sys/file.h>
> #include <signal.h>
> #include <sgtty.h>
> #include "sendmail.h"
> #include <arpa/nameser.h>
> #include <resolv.h>
> 
42c50
< **	Sendmail is driven by tables read in from /etc/sendmail/sendmail.cf
---
> **	Sendmail is driven by tables read in from /usr/lib/sendmail.cf
66,68d73
< 
< 
< 
88,94d92
< #if	NeXT_MOD
< # ifdef QUEUE
< int		OnlyRunId;	/* Queue ID from -M to run, or zero */
< char 		*OnlyRunRecip;	/* Recipient name from -R to run, or zero */
< # endif QUEUE
< #endif	NeXT_MOD
< 
101,105d98
< 
< 
< 
< 
< 
122d114
< #ifdef	vax
124d115
< #endif	vax
134,136d124
< #if	NeXT_MOD
< 	extern int DtableSize;
< #endif	NeXT_MOD
138d125
< #ifdef	vax
151c138,141
< #endif	vax
---
> 
> 	/* Enforce use of local time */
> 	unsetenv("TZ");
> 
153a144
> 	**	But also be sure that 0, 1, & 2 are open.
156,162c147,150
< #if	NeXT_MOD
< 	DtableSize = getdtablesize();
< 
< 	for (i = 3; i < DtableSize; i++)
< #else	NeXT_MOD
< 	for (i = 3; i < 50; i++)
< #endif	NeXT_MOD
---
> 	i = open("/dev/null", O_RDWR);
> 	while (i >= 0 && i < 2)
> 		i = dup(i);
> 	for (i = getdtablesize(); i > 2; --i)
205d192
< # ifdef DEBUG
213d199
< # endif DEBUG
251d236
< # ifndef V6
253d237
< # endif V6
255,256c239
< # ifdef LOG
< # ifdef LOG_MAIL
---
> #ifdef LOG_MAIL
258,261c241,243
< # else LOG_MAIL
< 	openlog("sendmail", LOG_PID, 0);
< # endif LOG_MAIL
< # endif LOG
---
> #else 
> 	openlog("sendmail", LOG_PID);
> #endif 
269,271c251
< #if	NeXT_MOD
< 		initdomain();
< #endif	NeXT_MOD
---
> 
276d255
< #ifdef DEBUG
279d257
< #endif DEBUG
286d263
< #ifdef DEBUG
289d265
< #endif DEBUG
293,306d268
< #if	NeXT_MOD
< 		if ((p = index(jbuf, '.')) != NULL)
< 		{
< 		  /*
< 		   * If the full domain name is used, then make sure that
< 		   * the unqualified name is also recognized.
< 		   */
< 			*p = '\0';
< 			st = stab(jbuf, ST_CLASS, ST_FIND);
< 			if (st == NULL || !bitnset('w', st->s_class))
< 			    setclass('w', jbuf);
< 		}
< #endif	NeXT_MOD
< 
336,337c298,306
< # ifndef DAEMON
< 				syserr("Daemon mode not implemented");
---
> # ifdef DAEMON
> 				if (getuid() != 0) {
> 					usrerr("Permission denied");
> 					exit (EX_USAGE);
> 				}
> 				(void) unsetenv("HOSTALIASES");
> # else
> 				usrerr("Daemon mode not implemented");
> 				ExitStat = EX_USAGE;
342c311,312
< 				syserr("I don't speak SMTP");
---
> 				usrerr("I don't speak SMTP");
> 				ExitStat = EX_USAGE;
356c326,327
< 				syserr("Invalid operation mode %c", p[2]);
---
> 				usrerr("Invalid operation mode %c", p[2]);
> 				ExitStat = EX_USAGE;
364d334
< # ifdef DEBUG
368a339,341
> #ifdef NAMED_BIND
> 			_res.options |= RES_DEBUG;
> #endif
370d342
< # endif DEBUG
380c352,353
< 					syserr("No \"from\" person");
---
> 					usrerr("No \"from\" person");
> 					ExitStat = EX_USAGE;
387c360,361
< 				syserr("More than one \"from\" person");
---
> 				usrerr("More than one \"from\" person");
> 				ExitStat = EX_USAGE;
397c371,372
< 				syserr("Bad -F flag");
---
> 				usrerr("Bad -F flag");
> 				ExitStat = EX_USAGE;
408c383,384
< 				syserr("Bad hop count (%s)", p);
---
> 				usrerr("Bad hop count (%s)", p);
> 				ExitStat = EX_USAGE;
424a401,405
> 			if (getuid() != 0) {
> 				usrerr("Permission denied");
> 				exit (EX_USAGE);
> 			}
> 			(void) unsetenv("HOSTALIASES");
428c409,410
< 			syserr("I don't know about queues");
---
> 			usrerr("I don't know about queues");
> 			ExitStat = EX_USAGE;
454,475c436
< 
< #endif DBM
< #if	NeXT_MOD
< # ifdef QUEUE
< 		  case 'M':	/* Queue run takes certain Message-Id only */
< 			p += 2;
< 			if (*p == '\0' && ((p = *++av) == NULL || !isdigit(*p)))
< 			{
< 				syserr("Bad Message-Id (%s)", p);
< 				av--;
< 				break;
< 			}
< 			OnlyRunId = atoi(p);
< 			queuemode = TRUE;
< 			break;
< 
< 		  case 'R':	/* Queue run takes certain Recipients only */
< 			OnlyRunRecip = newstr(p+2);
< 			queuemode = TRUE;
< 			break;
< # endif QUEUE
< #endif	NeXT_MOD
---
> # endif DBM
529,531d489
< #if	NeXT_MOD
< 	LocalMailer->m_eol = "\n";
< 	ProgMailer->m_eol = "\n";
533,543d490
< #if	0
< 	/* enable remote delivery mode if requested */
< 	if (RemoteServer && RemoteServer[0]=='\0')
< 	{
< 		RemoteDefault();	
< 	} 
< 	if (RemoteServer && OpMode == MD_DELIVER && !queuemode && !GrabTo)
< 		exit (RemoteMode(from, av));
< #endif	0
< #endif	NeXT_MOD
< 
583d529
< # ifdef DEBUG
606d551
< # endif DEBUG
612,614d556
< #if	NeXT_MOD
< 	MainEnvelope.e_from = NullAddress;
< #endif	NeXT_MOD
637c579
< 			for (p = buf; isspace(*p); *p++)
---
> 			for (p = buf; isspace(*p); p++)
777d718
< # ifdef DEBUG
780d720
< # endif DEBUG
787d726
< 
813d751
< # ifdef DEBUG
816d753
< # endif DEBUG
847,848c784
< **		Unlocks the current job. (not NeXT_MOD)
< **		Requeues the current job. (NeXT_MOD)
---
> **		Unlocks the current job.
853,856d788
< #if	NeXT_MOD
< 	register ADDRESS *q;
< #endif	NeXT_MOD
< 
858,868d789
< #if	NeXT_MOD
< 	q = CurEnv->e_sendqueue;
< 	if (q != NULL && !bitset(EF_INQUEUE,CurEnv->e_flags) &&
< 		OpMode != MD_VERIFY) 
< 	{
< 		for (; q != NULL; q = q->q_next)
< 			if (q != &CurEnv->e_from)
< 				q->q_flags &= ~QDONTSEND;
< 		queueup(CurEnv, TRUE, Verbose);
< 	}
< #endif	NeXT_MOD
899,901c820
< #ifdef	YELLOWPAGES
< 	'%', MATCHYELLOW, '!', MATCHNYELLOW,
< #endif	YELLOWPAGES
---
> 
908,912d826
< #ifdef	YELLOWPAGES
< 	/*  the YP lookup characters */
< 	'{', YELLOWBEGIN,	'}', YELLOWEND,
< #endif	YELLOWPAGES
< 
980,982d893
< #if	NeXT_MOD
< 	f = creat(freezefile, FreezeMode);
< #else	NeXT_MOD
984d894
< #endif	NeXT_MOD
987c897
< 		syserr("Cannot freeze");
---
> 		syserr("Cannot freeze %s", freezefile);
1004c914
< 		syserr("Cannot freeze");
---
> 		syserr("Cannot freeze %s", freezefile);
1029,1032c939
< 	extern char edata;
< #ifdef	NeXT_MOD
< 	extern char end;
< #endif	NeXT_MOD
---
> 	extern char edata, end;
1053,1059d959
< #if	NeXT_MOD
< 		  /*
< 		   * Attempt to unlink the out-of-date freeze file
< 		   */
< 		(void) write(2, "Freeze file out of date\n", 25);
< 		(void) unlink(freezefile);
< #endif	NeXT_MOD
1107d1006
< #ifdef DEBUG
1116d1014
< #endif DEBUG
1147,1150d1044
< #if	NeXT_MOD
< 	if (CurEnv->e_xfp != NULL)
< 	    while ((fd = dup(fileno(CurEnv->e_xfp))) < 2 && fd > 0)
< #else	NeXT_MOD
1152d1045
< #endif	NeXT_MOD
Only in sendmail/src: newaliases.0
Only in sendmail/src: newaliases.1
diff -r sendmail.target/src/parseaddr.c sendmail/src/parseaddr.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)parseaddr.c	5.6 (Berkeley) 4/2/86";
< #endif not lint
---
> static char sccsid[] = "@(#)parseaddr.c	5.11 (Berkeley) 1/25/89";
> #endif /* not lint */
16,18d23
< #if	NeXT_MOD
< # include "errno.h"
< #endif	NeXT_MOD
79d83
< # ifdef DEBUG
82d85
< # endif DEBUG
157d159
< # ifdef DEBUG
163d164
< # endif DEBUG
185,187d185
< #if	NeXT_MOD
< 	if (m != NULL && !bitnset(M_USR_UPPER, m->m_flags))
< #else	NeXT_MOD
189d186
< #endif	NeXT_MOD
283d279
< # ifdef DEBUG
290d285
< # endif DEBUG
319d313
< # ifdef DEBUG
322d315
< # endif DEBUG
326,331d318
< #if	NeXT_MOD
< 			/* kludge \! for naive users (violates RFC 822) */
< 			if ((c == '!') && bslashmode)
< 				bslashmode = FALSE;
< 				
< #endif	NeXT_MOD
334,336d320
< #if	NeXT_MOD
< 				c |= 0200;
< #else	NeXT_MOD
340d323
< #endif	NeXT_MOD
393d375
< # ifdef DEBUG
396d377
< # endif DEBUG
408d388
< # ifdef DEBUG
415d394
< # endif DEBUG
462,465d440
< #ifdef	YELLOWPAGES
< 	if (c == MATCHCLASS || c == MATCHREPL || c == MATCHNCLASS ||
< 		 c == MATCHYELLOW || c == MATCHNYELLOW)
< #else	YELLOWPAGES
467d441
< #endif	YELLOWPAGES
532,535d505
< 	extern bool sameword();
< #if	NeXT_MOD
< 	char tokbuf[MAXNAME+1];		/* for concatenated class tokens */
< #endif	NeXT_MOD
552d521
< # ifdef DEBUG
558d526
< # endif DEBUG
567d534
< # ifdef DEBUG
576d542
< # endif DEBUG
592,605d557
< #if	NeXT_MOD
< 				char **oldavp;
< 
< 			  case MATCHNCLASS:
< 				/* match any single token not in a class */
< 				s = stab(ap, ST_CLASS, ST_FIND);
< 				if (s != NULL && bitnset(rp[1], s->s_class))
< 					goto backup;
< 
< 				/* match exactly one token */
< 				mlp->last = avp++;
< 				mlp++;
< 				break;
< 
607,628d558
< 				/* match any token in a class */
< 				/* from lel@ida.liu.se */
< 				oldavp = avp;
< 				*tokbuf = NULL;
< 				do
< 				{
< 					if (*avp == NULL)
< 					{
< 						avp = oldavp;
< 						goto backup;
< 					}
< 					(void) strcat(tokbuf, *avp++);
< 					s = stab(tokbuf, ST_CLASS, ST_FIND);
< 				} while (s == NULL ||
< 					!bitnset(rp[1], s->s_class));
< 				mlp->first = oldavp;
< 				mlp->last = avp-1;
< 				mlp++;
< 				break;
< 
< #else	NeXT_MOD
< 			  case MATCHCLASS:
641c571
< #endif	NeXT_MOD
---
> 
656,673d585
< #ifdef	YELLOWPAGES
< 			  case MATCHNYELLOW:
< 			  case MATCHYELLOW:
< 				/* match any token in (not in) a yellow
< 				 *  pages map.
< 				 */
< 				if (yellowmatch(ap,rp[1]))
< 				{
< 					if (*rp == MATCHNYELLOW)
< 						goto backup;
< 				}
< 				else if (*rp == MATCHYELLOW)
< 					goto backup;
< 				mlp->first = avp;
< 				mlp->last = avp++;
< 				mlp++;
< 				break;
< #endif	YELLOWPAGES
677c589
< 				if (!sameword(rp, ap))
---
> 				if (strcasecmp(rp, ap))
692,724d603
< #if	NeXT_MOD
< 	                        if (*rp == MATCHCLASS) {
< 	                          register STAB *s;
< 	                          char **oldavp;
<  
< 	                          /* attempt to extend binding */
< 	                          /* slow, concat version by lel@ida.liu.se */
<  
< 	                          oldavp = avp;
< 	                          *tokbuf = NULL;
< 	                          for (avp = mlp[-1].first;
< 	                               avp <= mlp[-1].last; avp++)
< 	                            (void)strcat(tokbuf, *avp);
<  
< 	                          do {
< 	                            if (*avp == NULL) {
< 	                              /* back out binding */
< 	                              avp = oldavp;
< 	                              mlp--;
< 	                              goto cantextend;
< 	                            }
< 	                            (void) strcat(tokbuf, *avp++);
< 	                            s = stab(tokbuf, ST_CLASS, ST_FIND);
< 	                          } while (s == NULL ||
< 	                                   !bitnset(rp[1], s->s_class));
<  
< 	                          /* found an extension */
< 	                          mlp[-1].last = avp-1;
< 	                          rvp++;
< 	                          break;
< 	                        }
< 			cantextend:
< #endif	NeXT_MOD
734,738d612
< #ifdef	YELLOWPAGES
< 				if (*rp == MATCHONE || *rp == MATCHNCLASS 
< 				     || *rp == MATCHYELLOW 
< 				     || *rp == MATCHNYELLOW)
< #else	YELLOWPAGES
741d614
< #endif	YELLOWPAGES
761d633
< # ifdef DEBUG
764d635
< # endif DEBUG
770d640
< # ifdef DEBUG
776d645
< # endif DEBUG
808d676
< # ifdef DEBUG
821d688
< # endif DEBUG
827,829d693
< #if	NeXT_MOD
< 						goto toolong;
< #else	NeXT_MOD
832d695
< #endif	NeXT_MOD
843,845d705
< #if	NeXT_MOD
< 					errno = ENOMEM;
< #endif	NeXT_MOD
920d779
< #ifdef	YELLOWPAGES
922,991d780
< 		**  Check for any YP replacements
< 		*/
< 
< 		for (rvp = npvp; *rvp != NULL; rvp++)
< 		{
< 			char **hbrvp;
< 			char **xpvp;
< 			int trsize;
< 			char *olddelimchar;
< 			char buf[MAXNAME + 1];
< 			char *pvpb1[MAXATOM + 1];
< 			char pvpbuf[PSBUFSIZE];
< 			char *mapname;
< 			extern char *DelimChar;
< 			extern char *macvalue();
< 
< 			if (**rvp != YELLOWBEGIN)
< 				continue;
< 			rvp++;
< 			mapname = macvalue(**rvp,CurEnv);
< 
< 			/*
< 			**  Got a YP replacement.
< 			**
< 			**	This could be optimized fairly easily.
< 			*/
< 
< 			hbrvp = rvp;
< 
< 			/* extract the match part */
< 			while (*++rvp != NULL && **rvp != YELLOWEND)
< 				continue;
< 			if (*rvp != NULL)
< 				*rvp++ = NULL;
< 
< 			/* save the remainder of the input string */
< 			trsize = (int) (avp - rvp + 1) * sizeof *rvp;
< 			bcopy((char *) rvp, (char *) pvpb1, trsize);
< 
< 			/* look it up */
< 			cataddr(hbrvp + 1, buf, sizeof buf);
< 			mapusername(mapname, buf, sizeof buf);
< 
< 			/* scan the new host name */
< 			olddelimchar = DelimChar;
< 			xpvp = prescan(buf, '\0', pvpbuf);
< 			DelimChar = olddelimchar;
< 			if (xpvp == NULL)
< 			{
< 				syserr("cannot prescan YP result: %s", buf);
< 				return;
< 			}
< 
< 			/* append it to the token list */
< 			for (avp = --hbrvp; *xpvp != NULL; xpvp++)
< 			{
< 				*avp++ = newstr(*xpvp);
< 				if (avp >= &npvp[MAXATOM])
< 					goto toolong;
< 			}
< 
< 			/* restore the old trailing information */
< 			for (xpvp = pvpb1; (*avp++ = *xpvp++) != NULL; )
< 				if (avp >= &npvp[MAXATOM])
< 					goto toolong;
< 
< 			break;
< 		}
< #endif	YELLOWPAGES
< 		/*
999d787
< # ifdef DEBUG
1002d789
< # endif DEBUG
1010d796
< # ifdef DEBUG
1016d801
< # endif DEBUG
1049,1052d833
< 	extern bool sameword();
< #if	NeXT_MOD
< 	extern ADDRESS NullAddress;
< #endif	NeXT_MOD
1056,1058d836
< #if	NeXT_MOD
< 	*a = NullAddress;
< #else	NeXT_MOD
1060d837
< #endif	NeXT_MOD
1065,1067d841
< #if	NeXT_MOD
< 		syserr("buildaddr: no mailer");
< #else	NeXT_MOD
1069d842
< #endif	NeXT_MOD
1073c846
< 	if (sameword(*tv, "error"))
---
> 	if (!strcasecmp(*tv, "error"))
1089,1091d861
< #if	NeXT_MOD
< 		usrerr("%s", buf);
< #else	NeXT_MOD
1093d862
< #endif	NeXT_MOD
1098c867
< 		if (sameword(m->m_name, *tv))
---
> 		if (!strcasecmp(m->m_name, *tv))
1112,1114d880
< #if	NeXT_MOD
< 		if (*tv==NULL || **tv++ != CANONHOST)
< #else	NeXT_MOD
1116d881
< #endif	NeXT_MOD
1130,1134c895
< #if	NeXT_MOD
< 	if (*tv==NULL || **tv != CANONUSER)
< #else	NeXT_MOD
< 	if (**tv != CANONUSER)
< #endif	NeXT_MOD
---
> 	if (*tv == NULL || **tv != CANONUSER)
1253,1254d1013
< # ifdef DEBUG
< 
1282d1040
< # endif DEBUG
1324d1081
< # ifdef DEBUG
1327d1083
< # endif DEBUG
1368,1378d1123
< #if	NeXT_MOD
< 			  /*
< 			   * WARNING: this is necessary because we want to
< 			   * get uucp domain names too, which means
< 			   * we have to do this before the from address
< 			   * gets defocused by ruleset 4.
< 			   */
< 			while (*qxq != NULL && **qxq != '>')
< 				*pxp++ = *qxq++;
< 			*pxp = NULL;
< #else	NeXT_MOD
1381d1125
< #endif	NeXT_MOD
1424d1167
< # ifdef DEBUG
1427d1169
< # endif DEBUG
diff -r sendmail.target/src/queue.c sendmail/src/queue.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
11d18
< 
12a20,28
> 
> #ifndef lint
> #ifdef QUEUE
> static char sccsid[] = "@(#)queue.c	5.26 (Berkeley) 1/1/89 (with queueing)";
> #else
> static char sccsid[] = "@(#)queue.c	5.26 (Berkeley) 1/1/89 (without queueing)";
> #endif
> #endif /* not lint */
> 
18,22c34
< # ifndef QUEUE
< # ifndef lint
< static char	SccsId[] = "@(#)queue.c	5.21 (Berkeley) 4/17/86	(no queueing)";
< # endif not lint
< # else QUEUE
---
> # ifdef QUEUE
24,27d35
< # ifndef lint
< static char	SccsId[] = "@(#)queue.c	5.21 (Berkeley) 4/17/86";
< # endif not lint
< 
43,47d50
< 
< #if	NeXT_MOD
< static dowork();
< static readqf();
< #endif	NeXT_MOD
90d92
< # ifdef DEBUG
93d94
< # endif DEBUG
140,141d140
< #if	NeXT_MOD
< #else	NeXT_MOD
157d155
< #ifdef DEBUG
163d160
< #endif DEBUG
166d162
< #endif	NeXT_MOD
188,190d183
< #if	NeXT_MOD
< 	nullmailer.m_argvsize = 10000;
< #endif	NeXT_MOD
197,201d189
< #if	NeXT_MOD
< 		if (bitset(H_ERRSTO,h->h_flags) && 
< 		    bitset(H_DEFAULT,h->h_flags))
< 		      errors_to(h, e);
< #endif	NeXT_MOD
240,266d227
< #if	NeXT_MOD
< 	/* output list of recipient addresses */
< 	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
< 	{
< 		if (queueall ? !bitset(QDONTSEND, q->q_flags) :
< 			       bitset(QQUEUEUP, q->q_flags))
< 		{
< 			fprintf(tfp, "R%s\n", q->q_paddr);
< 			if (announce)
< 			{
< 				e->e_to = q->q_paddr;
< 				message(Arpa_Info, "queued");
< 				if (LogLevel > 4)
< 					logdelivery("queued");
< 				e->e_to = NULL;
< 			}
< #ifdef DEBUG
< 			if (tTd(40, 1))
< 			{
< 				printf("queueing ");
< 				printaddr(q, FALSE);
< 			}
< #endif DEBUG
< 		}
< 	}
< #endif	NeXT_MOD
< 
275,283d235
< #if	NeXT_MOD
< 		holdsigs();
< 		if (rename(tf, qf) < 0) 
< 		{
< 			syserr("cannot rename(%s, %s), df=%s", tf, qf, e->e_df);
< 			(void) unlink(tf);
< 		}
< 		rlsesigs();
< #else	NeXT_MOD
288d239
< #endif	NeXT_MOD
297,349d247
< 
< #if	NeXT_MOD
< /*
< **  checkpoint -- rewrite the qf file to reflect the updated queue of
< **	recipients.  WARNING: This function assumes that the recipient
< **	lines are all at the END of the queue files, after all other lines.
< **		"others" points to the list of recipients that have NOT been
< **			processed yet.  We save any already processed 
< **			recipients that have been marked for queuing, plus
< **			all the non-processed recipients except those that
< **			have already been delivered to.
< **/
< checkpoint(e,others)
<     ENVELOPE *e;
<     ADDRESS *others;
<   {
<     register ADDRESS *to;
<     register FILE *qfp;
<     char buf[MAXFIELD];
<     extern char *fgetfolded();
<     long position;
< 
<     if (others==NULL) return;
<     qfp = fopen(queuename(e,'q'),"r+");
<     if (qfp==NULL) return;
< 
<     while (fgetfolded(buf, sizeof buf, qfp) != NULL)
<       {
< 	if (buf[0]=='R') break;
<         position = ftell(qfp);
<       }
<     if (feof(qfp) || ferror(qfp))
<       {
<         /*
< 	 * got an error reading the queue file - give up.
< 	 */
< 	 fclose(qfp);
< 	 return;
<       }
<     fseek(qfp,position,0);
<     for (to = e->e_sendqueue; to != NULL && to != others; to = to->q_next)
< 	if (bitset(QQUEUEUP, to->q_flags) )
< 	        fprintf(qfp, "R%s\n", to->q_paddr);
<     if (to != NULL)
<         for (; to != NULL; to = to->q_next)
< 	    if (!bitset(QDONTSEND, to->q_flags) || 
< 	         bitset(QQUEUEUP, to->q_flags) )
< 		    fprintf(qfp, "R%s\n", to->q_paddr);
<     ftruncate(fileno(qfp), ftell(qfp));
<     fclose(qfp);  
<     e->e_flags |= EF_INQUEUE;
<   }
< #endif	NeXT_MOD
435,436d332
< #if	NeXT_MOD
< #else	NeXT_MOD
442d337
< #endif	NeXT_MOD
464,470c359,361
< #if	NeXT_MOD
< 	/*
< 	 * Don't let dropenvelope() trash locked queue files!
< 	 */
< 	CurEnv->e_id = NULL;
< #endif	NeXT_MOD
< 	finis();
---
> 
> 	/* exit without the usual cleanup */
> 	exit(ExitStat);
491,493d381
< #if	NeXT_MOD
< # define NEED_R		004
< #endif	NeXT_MOD
495d382
< 
506,509d392
< #if	NeXT_MOD
< 	extern int	OnlyRunId;		/* main.c */
< 	extern char	*OnlyRunRecip;		/* main.c */
< #endif	NeXT_MOD
543,554d425
< #if	NeXT_MOD
< 		/*
< 		** If we're only interested in a particular job, check
< 		** for that one.
< 		*/
< 		if (OnlyRunId) {
< 			if (OnlyRunId != atoi(&d->d_name[4])) {
< 				continue;
< 			}
< 		}
< #endif	NeXT_MOD
< 
563d433
< #ifdef DEBUG
567d436
< #endif DEBUG
581,584d449
< #if	NeXT_MOD
< 		if (OnlyRunRecip != 0)
< 			i |= NEED_R;
< #endif	NeXT_MOD
600,615d464
< #if	NeXT_MOD
< 			  case 'R':
< 			        if (i |= NEED_R)
< 			    {
< 				register char *sp;
< 				for (sp = &lbuf[1]; *sp; sp++)
< 				{
< 					if (*sp == OnlyRunRecip[0] && 
< 					    strncmp(sp, OnlyRunRecip,
< 						strlen(OnlyRunRecip)) == 0) {
< 							i &= ~NEED_R;
< 							break;
< 					}
< 				}
< 			    }
< #endif	NeXT_MOD
620,624d468
< #if	NeXT_MOD
< 		/* If recip name didn't match, don't take this queue entry */
< 		if ( (shouldqueue(wlist[wn].w_pri) && !doall) ||
< 		       (i & NEED_R)!= 0)
< #else	NeXT_MOD
626d469
< #endif	NeXT_MOD
657d499
< # ifdef DEBUG
663d504
< # endif DEBUG
710d550
< static
714,717d553
< #if	NeXT_MOD
< 	ENVELOPE *newenvelope();
< 	extern ENVELOPE BlankEnvelope;
< #else	NeXT_MOD
720d555
< #endif	NeXT_MO
722d556
< # ifdef DEBUG
725d558
< # endif DEBUG
738,739d570
< #if	NeXT_MOD
< #else	NeXT_MOD
760d590
< #endif	NeXT_MOD
762,764c592
< 		**  CHILD except for NeXT_NFS which in order to use the
< 		**	cache, delays forking here.
< 		**
---
> 		**  CHILD
773,777d600
< #if	NeXT_MOD
< 		closexscript(CurEnv);
< 		CurEnv = newenvelope(CurEnv);
< 		CurEnv->e_flags = BlankEnvelope.e_flags;
< #else	NeXT_MOD
779d601
< #endif	NeXT_MOD
783,787d604
< 
< #if	NeXT_MOD
< 		setproctitle(CurEnv->e_id, 0);	/* Set process name for ps */
< #endif	NeXT_MOD
< 
805,806d621
< #if	NeXT_MOD
< #else	NeXT_MOD
810d624
< #endif	NeXT_MOD
826,828d639
< #if	NeXT_MOD
< 	dropenvelope(CurEnv);
< #else	NeXT_MOD
844d654
< #endif	NeXT_NFS
862d671
< static
890d698
< # ifdef DEBUG
893d700
< # endif DEBUG
1001,1003d807
< #ifdef	NeXT_MOD
< ! 		printf(")\n--QID-- -Size- ----Q-Time----- ------------Sender/Recipient------------\n");
< #else	NeXT_MOD
1005d808
< #endif	NeXT_MOD
1016,1017d818
< #if	NeXT_MOD
< #else	NeXT_MOD
1023d823
< #endif	NeXT_MOD
1029,1033d828
< #if	NeXT_MOD
< 		else
< 			printf(" ");
< 		if (shouldqueue(w->w_pri))
< #else	NeXT_MOD
1035d829
< #endif	NeXT_MOD
1040,1047c834
< #if	NeXT_MOD
< 		if (f == NULL)
< 		{
< 			printf(" (finished)\n");
< 			errno = 0;
< 			continue;
< 		}
< #endif	NeXT_MOD
---
> 
1060,1062d846
< #if	NeXT_MOD
< 					printf("%5ld %10ld %.12s %.38s", dfsize,
< #else	NeXT_MOD
1064d847
< #endif	NeXT_MOD
1068,1070d850
< #if	NeXT_MOD
< 					printf("%5ld %.16s %.45s", dfsize,
< #else	NeXT_MOD
1072d851
< #endif	NeXT_MOD
1075,1077d853
< #if	NeXT_MOD
< 					printf("\n%57s", message);
< #else	NeXT_MOD
1079d854
< #endif	NeXT_MOD
1172d946
< # ifdef DEBUG
1175d948
< # endif DEBUG
1178,1191d950
< # if NeXT_MOD
< 			/*
< 			 * Access doesn't work for super-user,
< 			 * better to use stat to see if the file
< 			 * exists.
< 			 */
< 			{
< 				struct stat st;
< 				int i, j, k, l;
< 				if (   (i=stat(lf, &st)) != -1 || (j=errno) != ENOENT
< 				    || (k=stat(qf, &st)) != -1 || (l=errno) != ENOENT)
< 				    	continue;
< 			}
< # else NeXT_MOD
1194d952
< # endif NeXT_MOD
1199a958,962
> 				if (errno == ENOSPC) {
> 					syserr("queuename: Cannot create \"%s\" in \"%s\"",
> 						nf, QueueDir);
> 					exit(EX_UNAVAILABLE);
> 				}
1215,1226d977
< #if	NeXT_MOD
< 		/*
< 		 * The next test used to check for c1 >= '~', but there's
< 		 * no reason to go thru 26**2 permutations; 52 should do.
< 		 */
< 		if (c1 >= 'B' && c2 >= 'Z')
< 		{
< 			if (type != '\0') {
< 			     syserr("queuename: Cannot create \"%s\" in \"%s\"",
< 				    qf, QueueDir);
< 			}
< #else	NeXT_MOD
1231d981
< #endif	NeXT_MOD
1236d985
< # ifdef DEBUG
1243d991
< # endif DEBUG
1249d996
< # ifdef DEBUG
1252d998
< # endif DEBUG
1271,1273d1016
< #if	NeXT_MOD
< 	if (e->e_id == NULL) return;
< #endif	NeXT_MOD
1275d1017
< #ifdef DEBUG
1281d1022
< #endif DEBUG
diff -r sendmail.target/src/readcf.c sendmail/src/readcf.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)readcf.c	5.10 (Berkeley) 1/11/86";
< #endif not lint
---
> static char sccsid[] = "@(#)readcf.c	5.18 (Berkeley) 1/19/89";
> #endif /* not lint */
26d33
< **		Cxword		Put word into class x.
27a35
> **		Cxword		Put word into class x.
32,34d39
< **		Fx|cmd		Read standard output of cmd for lines
< **				to put into class x.  (NeXT_MOD)
< **				1st word on line goes in.
39c44
< **		Sn		Define rewriting set n.
---
> **		Sn		Use rewriting set n.
42,44c47,48
< **		Mname, arg=val...
< **				Define mailer.  name = internal name.
< **				rest are keyword arguments
---
> **		Mn arg=val...	Define mailer.  n is the internal name.
> **				Args specify mailer parameters.
47,48d50
< **		Tname		Declare trusted users
< **		
80,90d81
< #if	NeXT_MOD
< 		extern char *ConfFile2;
< 
< 		cfname = ConfFile2;
< 		cf = fopen(cfname, "r");
< 		if (cf == NULL)
< 		{
< 			syserr("cannot open %s", cfname);
< 			exit(EX_OSFILE);
< 		}
< #else	NeXT_MOD
93d83
< #endif	NeXT_MOD
190,198d179
< #if	NeXT_MOD
< 				/*
< 				 * GNU replaced the "scanf string" feature with
< 				 * a "read class from shell cmd" feature.
< 				 * It might be more general, but we also
< 				 * need backward compatibility,
< 				 */
< 				fileclass(buf[1], &buf[2]);
< #else	NeXT_MOD
211d191
< #endif	NeXT_MOD
314,316c294
< **		filename-- name of file to read.
< **			NeXT_MOD: If it begins with a '|', a pipe from
< **				  that command is read instead.
---
> **		filename -- name of file to read.
325,328c303
< **			the named class. (not NeXT_MOD)
< **		puts the first word of each line in file filename (or each
< **			line of output from program 'filename') into
< **			the named class. (NeXT_MOD)
---
> **			the named class.
330,348d304
< #if	NeXT_MOD
< fileclass(class, filename)
< 	int class;
< 	char *filename;
< {
< 	register FILE *f;
< 	char *fmt;
< 	register char *p;
< 	char buf[MAXLINE];
< 	
< 	  /*
< 	   * remove leading and trailing spaces and tabs
< 	   */
< 	for ( p=filename; *p != '\0' && isspace(*p); p++)
< 		continue;
< 	for ( filename=p; *p != '\0'; p++)
< 		continue;
< 	for ( p--; isspace(*p) && p != filename; p--)
< 		*p = '\0';
350,372d305
< 	fmt = "%s";
< 	if ('|' == filename[0]) {
< 		  /*
< 		   * if reading from a program, use entire line including
< 		   * arguments as command, and always use default format.
< 		   */
< 		f = popen(&filename[1], "r");
< 	} else {
< 		  /*
< 		   * reading from a file, treat the optional argument as
< 		   * a scanf format string as in BSD.
< 		   */
< 		for ( p=filename; *p != '\0' && !isspace(*p); p++)
< 			continue;
< 		if (*p != '\0') {
< 			*p = '\0';
< 			while (isspace(*++p))
< 				continue;
< 			fmt = p;
< 		}
< 		f = fopen(filename, "r");
< 	}
< #else	NeXT_MOD
382d314
< #endif	NeXT_MOD
392,393d323
< #if	NeXT_MOD
< #else	NeXT_MOD
395d324
< #endif	NeXT_MOD
430,432d358
< #if	NeXT_MOD
< 			continue;
< #endif	NeXT_MOD
436,442d361
< #if	NeXT_MOD
< 	if ('|' == filename[0]) {
< 		(void) pclose(f);
< 	} else {
< 		(void) fclose(f);
< 	}
< #else	NeXT_MOD
444d362
< #endif	NeXT_MOD
485,488d402
< #if	NeXT_MOD
< 	m->m_eol = "\r\n";
< 	m->m_argvsize = 10000;
< #else	NeXT_MOD
490d403
< #endif	NeXT_MOD
557,561d469
< #if	NeXT_MOD
< 		  case 'L':		/* maximum length of argv */
< 			m->m_argvsize = atoi(p);
< 			break;
< #endif	NeXT_MOD
573,580d480
< #if	NeXT_MOD
< 	if (m->m_argv == NULL)
< 	{
< 		syserr("mailer %s does not have an argument vector", 
< 			m->m_name);
< 		return;
< 	}	
< #endif	NeXT_MOD
706,707d605
< # ifdef DEBUG
< 
729d626
< # endif DEBUG
751,755d647
< # ifdef SMTP
< # ifdef WIZ
< extern char	*WizWord;		/* the stored wizard password */
< # endif WIZ
< # endif SMTP
767,769d658
< #ifdef	YELLOWPAGES
< 	extern char *AliasMap;
< #endif	YELLOWPAGES
773d661
< # ifdef DEBUG
776d663
< # endif DEBUG
784d670
< # ifdef DEBUG
787d672
< # endif DEBUG
795c680
< 	if (!safe && getruid() == 0)
---
> 	if (!safe && getuid() == 0)
797,799d681
< #if	NeXT_MOD
< 	if (!safe && index("bdeiLmMorRsvY", opt) == NULL)
< #else	NeXT_MOD
801d682
< #endif	NeXT_MOD
803,807c684
< # ifdef DEBUG
< 		if (tTd(37, 1))
< 			printf(" (unsafe)");
< # endif DEBUG
< 		if (getruid() != geteuid())
---
> 		if (opt != 'M' || val[0] != 'r' && val[0] != 's')
809,811c686,693
< 			printf("(Resetting uid)\n");
< 			(void) setgid(getgid());
< 			(void) setuid(getuid());
---
> 			if (tTd(37, 1))
> 				printf(" (unsafe)");
> 			if (getuid() != geteuid())
> 			{
> 				printf("(Resetting uid)\n");
> 				(void) setgid(getgid());
> 				(void) setuid(getuid());
> 			}
814d695
< #ifdef DEBUG
817d697
< #endif DEBUG
835,840d714
< #if	NeXT_MOD
< 	  case 'b':		/* number of recipients of "big" messages */
< 		RecipThreshold = atoi(val);
< 		break;
< #endif	NeXT_MOD
< 
917a792,795
> 	  case 'I':		/* use internet domain name server */
> 		UseNameServer = atobool(val);
> 		break;
> 
971,976d848
< #if	NeXT_MOD && 0
< 	  case 'R':		/* remote mail delivery */
< 	  	RemoteServer = newstr(val);
< 	  	break;
< #endif	NeXT_MOD && 0
< 
990c862
< 		break;
---
> 		/*FALLTHROUGH*/
993,1000d864
< # ifdef V6
< 		StdTimezone = newstr(val);
< 		DstTimezone = index(StdTimeZone, ',');
< 		if (DstTimezone == NULL)
< 			syserr("bad time zone spec");
< 		else
< 			*DstTimezone++ = '\0';
< # endif V6
1011,1018d874
< # ifdef SMTP
< # ifdef WIZ
< 	  case 'W':		/* set the wizards password */
< 		WizWord = newstr(val);
< 		break;
< # endif WIZ
< # endif SMTP
< 
1031,1034d886
< #ifdef	YELLOWPAGES
< 	  case 'Y':		/* set Yellow Pages alias map */
< 	  	AliasMap = newstr(val);
< #else	YELLOWPAGES
1037d888
< #endif	YELLOWPAGES
diff -r sendmail.target/src/recipient.c sendmail/src/recipient.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)recipient.c	5.7 (Berkeley) 1/9/86";
< #endif not lint
---
> static char sccsid[] = "@(#)recipient.c	5.14 (Berkeley) 1/1/89";
> #endif /* not lint */
19,22d26
< #ifdef	NeXT_MOD
< ADDRESS *getctladdr();
< #endif	NeXT_MOD
< 
45,47d48
< #if	NeXT_MOD
< # define MAXRCRSN	50
< #else	NeXT_MOD
49d49
< #endif	NeXT_MOD
62d61
< # ifdef DEBUG
68d66
< # endif DEBUG
105,108d102
< #if	NeXT_MOD
< 		{
< 			if (tTd(27, 1))
< 			    printf("Found self referece %s\n",a->q_paddr);
110,113d103
< 		}
< #else	NeXT_MOD
< 			selfref = TRUE;
< #endif	NeXT_MOD
117,141d106
< #ifdef	YELLOWPAGES
< 		/* inherit the fact that we were a domain-wide alias */
< 		if (ctladdr != NULL && bitset(QDOMAIN, ctladdr->q_flags))
< 		  {
< 		     char *p;
< 		     extern bool sameword();
< 		
< 		     p = rindex(a->q_paddr,'@');
< 		     if (p)
< 		       {
< 		         STAB *s;
< 			 s = stab(p+1, ST_CLASS, ST_FIND);
< 			 if ( (s != NULL && bitnset('w', s->s_class)) ||
< 			       sameword(macvalue('w',CurEnv),p+1) )
< 			   {
< 			if (tTd(27, 1))
< 			    printf("Found local alias %s\n",a->q_paddr);
< 			   	a->q_flags |= QWASLOCAL;
< 				if (selfref) ctladdr->q_flags |= QWASLOCAL;
< 			   }
< ;
< 		       }
< 		     a->q_flags |= QDOMAIN;
< 		  }
< #endif	YELLOWPAGES
194,195d158
< #ifdef	NeXT_MOD
< #else	NeXT_MOD
197d159
< #endif	NeXT_MOD
203d164
< # ifdef DEBUG
209d169
< # endif DEBUG
243c203
< 		if (a->q_alias == NULL && !tTd(0, 1) && !QueueRun && !ForceMail)
---
> 		if (a->q_alias == NULL && !QueueRun && !ForceMail)
245,246c205
< #if	NeXT_MOD
< 			a->q_flags |= QDONTSEND;
---
> 			a->q_flags |= QDONTSEND|QBADADDR;
248,251d206
< #else	NeXT_MOD
< 			usrerr("Cannot mail directly to programs");
< 			a->q_flags |= QDONTSEND;
< #endif	NeXT_MOD
268,273d222
< #if	NeXT_MOD
< 			if (bitset(QWASLOCAL,a->q_flags) && 
< 			    bitset(QDONTSEND, q->q_flags))
< 			      continue;
< #endif	NeXT_MOD
< # ifdef DEBUG
279d227
< # endif DEBUG
302c250,252
< 			if (a->q_alias == NULL && !tTd(0, 1) && !QueueRun && !ForceMail)
---
> 			if (a->q_alias == NULL && !QueueRun && !ForceMail)
> 			{
> 				a->q_flags |= QBADADDR;
303a254
> 			}
332c283
< 			if (a->q_alias == NULL && !tTd(0, 1) && !QueueRun && !ForceMail)
---
> 			if (a->q_alias == NULL && !QueueRun && !ForceMail)
334,335c285
< #if	NeXT_MOD
< 				a->q_flags |= QDONTSEND;	
---
> 				a->q_flags |= QDONTSEND|QBADADDR;
337,341c287
< #else	NeXT_MOD
< 				usrerr("Cannot mail directly to files");
< 				a->q_flags |= QDONTSEND;
< #endif	NeXT_MOD
< 		}
---
> 			}
353,362d298
< #if	NeXT_MOD
< 			if (bitset(QDOMAIN,a->q_flags) && !bitset(QWASLOCAL,a->q_flags))
< 			  {
< 			  	/*
< 				 * we finally resolved to an alias via the 
< 				 * yellow pages with no host name in it.
< 				 * send upstairs to the domain host.
< 				 */
< # ifdef YELLOWPAGES
< 			    extern char *ypDomain;
364,372d299
< 			    (void) strcat(buf,"@");
< 			    (void) strcat(buf, ypDomain);
< 			    a = parseaddr(buf,a,1,0);
< 			    if (tTd(27, 1))
< 	printf("User %s (%s) is really on domain server\n",a->q_user, buf);
< # endif YELLOWPAGES
< 			    return (a);
< 			  }
< #endif	NeXT_MOD
432,433d358
< #if	NeXT_MOD
< #else	NeXT_MOD
440d364
< #endif	NeXT_MOD
449,451d372
< #if	NeXT_MOD
< 		if (*p == (SpaceSub & 0177))
< #else	NeXT_MOD
453d373
< #endif	NeXT_MOD
460d379
< 		extern bool sameword();
462,465d380
< #if	NeXT_MOD
< 		if (sameword(pw->pw_name, name))
< 			return (pw);
< #endif	NeXT_MOD
467c382
< 		if (index(buf, ' ') != NULL && sameword(buf, name))
---
> 		if (index(buf, ' ') != NULL && !strcasecmp(buf, name))
576,579d490
< #if	NeXT_MOD
< 	/* Names from include files are not domain-wide */
< 	ctladdr->q_flags &= ~QDOMAIN;
< #endif	NeXT_MOD
589,591d499
< #if	NeXT_MOD
< 		LineNumber++;
< #endif	NeXT_MOD
623d530
< 	extern bool sameword();
627c534
< 		if (argv[0] != NULL && argv[1] != NULL && sameword(argv[0], "at"))
---
> 		if (argv[0] != NULL && argv[1] != NULL && !strcasecmp(argv[0], "at"))
Only in sendmail.target/src: remote.c
diff -r sendmail.target/src/savemail.c sendmail/src/savemail.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)savemail.c	5.7 (Berkeley) 12/7/85";
< #endif not lint
---
> static char sccsid[] = "@(#)savemail.c	5.11 (Berkeley) 1/1/89";
> #endif /* not lint */
62d69
< # ifdef DEBUG
65d71
< # endif DEBUG
121,123d126
< #if	NeXT_MOD
< 		state = ESM_POSTMASTER;
< #else	NeXT_MOD
125d127
< #endif	NeXT_MOD
139,141d140
< #if	NeXT_MOD
< 		state = ESM_POSTMASTER;
< #else	NeXT_MOD
143d141
< #endif	NeXT_MOD
149d146
< # ifdef DEBUG
152d148
< # endif DEBUG
201,202d196
< 			if (ferror(stdout))
< 				(void) syserr("savemail: stdout: write err");
219,222d212
< #if	NeXT_MOD
< 			if (e->e_message == NULL) 
< 				e->e_message =  
< 				    newstr("Unable to deliver mail");
225,250d214
< 				if (e->e_errorqueue == NULL) {
< 					e->e_flags |= EF_ERRSTOFROM;
< 					sendtolist(e->e_from.q_paddr, 
< 						(ADDRESS *) NULL,
< 						&e->e_errorqueue);
< 				}
< 				q = e->e_errorqueue;
< 				if (returntosender(e->e_message, q, TRUE))
< 					state = ESM_USRTMP;
< 				else
< 					state = ESM_DONE;
< 				break;
< 			}
< 			/* deliver a cc: to the postmaster if desired */
< 			q = NULL;
< 			if (PostMasterCopy != NULL &&
< 			    PostMasterCopy[0] != '\0')
< 			{
< 				sendtolist(PostMasterCopy,
< 						(ADDRESS *) NULL, &q);
< 				(void) returntosender(e->e_message, q, FALSE);
< 			}
< 			state = ESM_MAIL;
< #else	NeXT_MOD
< 			if (state == ESM_MAIL)
< 			{
282d245
< #endif	NeXT_MOD
283a247
> 
310,311d273
< #if	NeXT_MOD
< #else	NeXT_MOD
313d274
< #endif	NeXT_MOD
411d371
< # ifdef DEBUG
419d378
< # endif DEBUG
Only in sendmail/src: sendmail.0
Only in sendmail/src: sendmail.8
diff -r sendmail.target/src/sendmail.h sendmail/src/sendmail.h
2,11c2,19
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< **
< **	@(#)sendmail.h	5.8 (Berkeley) 1/10/86
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  *
>  *	@(#)sendmail.h	5.14 (Berkeley) 11/17/88
>  */
17,18d24
< 
< 
22c28
< static char SmailSccsId[] =	"@(#)sendmail.h	5.8		1/10/86";
---
> static char SmailSccsId[] =	"@(#)sendmail.h	5.14		11/17/88";
35,37d40
< #if	NeXT_MOD
< # include <syslog.h>
< #else	NeXT_MOD
39d41
< #endif	NeXT_MOD
107c109
< # define QPRIMARY	000010	/* set from argv or RCPT TO: command */
---
> # define QPRIMARY	000010	/* set from argv */
109,112d110
< #if	NeXT_MOD
< # define QDOMAIN	000040	/* was result of a domain-wide alias */
< # define QWASLOCAL	000100	/* we've seen our host name, stop yellow paging */
< #endif	NeXT_MOD
136,138d133
< #if	NeXT_MOD
< 	int	m_argvsize;	/* size limit on argv    to this mailer */
< #endif	NeXT_MOD
167,169d161
< #if	NeXT_MOD
< EXTERN char	AlreadyKnown;		/* don't log unless this is zero */
< #endif	NeXT_MOD
211,213d202
< #if	NeXT_MOD
< # define H_ERRSTO	02000	/* this is an errors-to: line */
< #endif	NeXT_MOD
235,237d223
< #if	NeXT_MOD
< 	long		e_bodysize;	/* size of the message body in bytes */
< #endif	NeXT_MOD
266,268d251
< #if	NeXT_MOD
< #define EF_ERRSTOFROM	001000		/* DON'T add an errors-to: line */
< #endif	NeXT_MOD
303,307d285
< 
< #if	NeXT_MOD
< # define WKRECIPFACT	50		/* bytes each recipient is worth */
< # define WKTIMEFACT	(-1000)		/* bytes each reprocessing is worth */
< #endif	NeXT_MOD
351,356d328
< #ifdef	YELLOWPAGES
< # define MATCHYELLOW	'\037'	/* yellow pages map to match */
< # define MATCHNYELLOW	'\017'	/* yellow pages map to not match */
< # define YELLOWBEGIN	'\016'  /* start of a YP replacement */
< # define YELLOWEND	'\016'  /* end of a YP replacement */
< #endif	YELLOWPAGES
372,383d343
< #if	NeXT_MOD
< 	struct in_addr	h_addrlist[MAXMXHOSTS+1]; /* Internet addresses */
< 	u_short		h_index;	/* index into above */
< 	u_short		h_port;		/* host port number */
< 	unsigned char	h_fd;		/* File descriptor, if connected */
< 	unsigned	h_valid:1;	/* 1=this entry has valid info */
< 	unsigned	h_exists:1;	/* 1=host name/addr is known */
< 	unsigned	h_tried:1;	/* 1=tried to connect */
< 	unsigned	h_down:1;	/* 1=tried & failed connect */
< 	unsigned	h_open:1;	/* 1=currently connected */
< 	int		h_errno;	/* error on last connection */
< #else	NeXT_MOD
389d348
< #endif	NeXT_MOD
392,401d350
< #if	NeXT_MOD
< /*
<  * chache entry for mail exchanger information
<  */
< struct mxinfo
< {
< 	int mx_number;			/* number of records */
< 	char *mx_hosts[MAXMXHOSTS+1];	/* names of exchangers */
< };
< #endif	NeXT_MOD
404,406d352
< #if	NeXT_MOD
< # define ENAMESER 999			/* name service time out */
< #else	NeXT_MOD
408d353
< #endif	NeXT_MOD
429,431d373
< #if	NeXT_MOD
< 		struct mxinfo sv_mxinfo;	/* mail exchanger info */
< #endif	NeXT_MOD
445,447d386
< #if	NeXT_MOD
< # define ST_MX		6	/* a mail exchanger list */
< #endif	NeXT_MOD
453,454d391
< #if	NeXT_MOD
< #else	NeXT_MOD
456d392
< #endif	NeXT_MOD
557a494
> EXTERN bool	UseNameServer;	/* use internet domain name server */
586a524
> EXTERN struct	sockaddr_in RealHostAddr;/* address of host we are talking to */
598a537
> EXTERN int	Nmx;			/* number of MX RRs */
599a539
> EXTERN char	*MxHosts[MAXMXHOSTS+1];	/* for MX RRs */
602,607d541
< #if	NeXT_MOD
< #if	0
< EXTERN char	*RemoteServer;	/* remote mail server name */
< #endif	0
< EXTERN int	RecipThreshold;	/* minimum recipients to prohibit null msg */
< #endif	NeXT_MOD
651,658d584
< extern bool	checkcompat();
< extern bool	shouldqueue();
< extern bool	sameword();
< extern bool	safefile();
< extern bool	atobool();
< extern bool	bitintersect();
< extern bool	bitzerop();
< 
diff -r sendmail.target/src/sendmail.hf sendmail/src/sendmail.hf
1c1,12
< @(#)	sendmail.hf	3.2	11/21/81
---
> @(#)	sendmail.hf	4.2	6/7/85
> cpyr	
> cpyr	Sendmail
> cpyr	Copyright (c) 1983  Eric P. Allman
> cpyr	Berkeley, California
> cpyr	
> cpyr	Copyright (c) 1983 Regents of the University of California.
> cpyr	All rights reserved.  The Berkeley software License Agreement
> cpyr	specifies the terms and conditions for redistribution.
> cpyr	
> cpyr	@(#)sendmail.hf	4.2 (Berkeley) 6/7/85
> cpyr	
4c15
< smtp		NOOP	QUIT	HELP	VRFY
---
> smtp		NOOP	QUIT	HELP	VRFY	EXPN
5a17,19
> smtp	To report bugs in the implementation contact eric@Berkeley.ARPA
> smtp	or eric@UCB-ARPA.ARPA.
> smtp	For local information contact postmaster at this site.
19c33
< rset		Resets the system -- same as QUIT in this implementation.
---
> rset		Resets the system.
21c35
< quit		Exit sendmail
---
> quit		Exit sendmail (SMTP).
24a39,40
> expn	EXPN <recipient>
> expn		Same as VRFY in this implementation.
37a54,56
> turn	TURN
> turn		Reverses the direction of the connection.  Not currently
> turn		implemented.
diff -r sendmail.target/src/srvrsmtp.c sendmail/src/srvrsmtp.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
10a19
> # include "sendmail.h"
11a21,28
> #ifndef lint
> #ifdef SMTP
> static char sccsid[] = "@(#)srvrsmtp.c	5.27 (Berkeley) 1/18/89 (with SMTP)";
> #else
> static char sccsid[] = "@(#)srvrsmtp.c	5.27 (Berkeley) 1/18/89 (without SMTP)";
> #endif
> #endif /* not lint */
> 
13d29
< # include "sendmail.h"
16,20c32
< # ifndef SMTP
< # ifndef lint
< static char	SccsId[] = "@(#)srvrsmtp.c	5.18 (Berkeley) 1/5/86	(no SMTP)";
< # endif not lint
< # else SMTP
---
> # ifdef SMTP
22,25d33
< # ifndef lint
< static char	SccsId[] = "@(#)srvrsmtp.c	5.18 (Berkeley) 1/5/86";
< # endif not lint
< 
57,62c65,69
< # define CMDDBGQSHOW	10	/* showq -- show send queue (DEBUG) */
< # define CMDDBGDEBUG	11	/* debug -- set debug mode */
< # define CMDVERB	12	/* verb -- go into verbose mode */
< # define CMDDBGKILL	13	/* kill -- kill sendmail */
< # define CMDDBGWIZ	14	/* wiz -- become a wizard */
< # define CMDONEX	15	/* onex -- sending one transaction only */
---
> # define CMDONEX	10	/* onex -- sending one transaction only */
> # define CMDVERB	11	/* verb -- go into verbose mode */
> /* debugging-only commands, only enabled if SMTPDEBUG is defined */
> # define CMDDBGQSHOW	12	/* showq -- show send queue */
> # define CMDDBGDEBUG	13	/* debug -- set debug mode */
78c85,88
< # if	defined(DEBUG) && !(NeXT_MOD)
---
> 	/*
> 	 * remaining commands are here only
> 	 * to trap and log attempts to use them
> 	 */
81,87d90
< # endif defined(DEBUG) && !(NeXT_MOD)
< # ifdef WIZ
< 	"kill",		CMDDBGKILL,
< # endif WIZ
< #if	!defined(NeXT_MOD) || defined(WIZ)
< 	"wiz",		CMDDBGWIZ,
< #endif	WIZ
91,96d93
< # ifdef WIZ
< bool	IsWiz = FALSE;			/* set if we are a wizard */
< # endif WIZ
< #if	!defined(NeXT_MOD) || defined(WIZ)
< char	*WizWord;			/* the wizard word to compare against */
< #endif	WIZ
98,99d94
< #if	NeXT_MOD
< #else	NeXT_MOD
101d95
< #endif	NeXT_MOD
105,147d98
< static char *skipword();
< 
< #if	NeXT_MOD
< /**
<  ** GRABCOMMAND - parse one smtp command line
<  **/
< char *grabcommand( inp, stringp, cmdp)
<     char *inp;				/* input line */
<     char **stringp;			/* returns the command string */
<     struct cmd **cmdp;			/* returns the command structure */
<   {
< 	register struct cmd *c;
< 	register char *p;
< 	extern bool sameword();
< 
< 	p = inp;
< 	/* clean up end of line */
< 	fixcrlf(p, TRUE);
< 
< 	/* echo command to transcript */
< 	if (CurEnv->e_xfp != NULL)
< 		fprintf(CurEnv->e_xfp, "<<< %s\n", inp);
< 
< 	/* break off command */
< 	for (p = inp; isspace(*p); p++)
< 		continue;
< 	*stringp = p;
< 	while (*++p != '\0' && !isspace(*p))
< 		continue;
< 	if (*p != '\0')
< 		*p++ = '\0';
< 
< 	/* decode command */
< 	for (c = CmdTab; c->cmdname != NULL; c++)
< 	{
< 		if (sameword(c->cmdname, *stringp))
< 			break;
< 	}
< 	*cmdp = c;
< 	return p;
<  }
< #endif	NeXT_MOD
< 
151,154c102
< #if	!(NeXT_MOD)
< 	register
< #endif	!(NeXT_MOD)
< 		struct cmd *c;
---
> 	register struct cmd *c;
156,160c104
< #if	NeXT_MOD
< 	bool wasquit;			/* one transaction (quit after .) */
< #else	NeXT_MOD
< 	extern bool sameword();
< #endif	NeXT_MOD
---
> 	extern char *skipword();
163a108
> 	char *sendinghost;
165d109
< #if	!(NeXT_MOD)
167d110
< #endif	!(NeXT_MOD)
169,171d111
< 	extern tick();
< 	extern bool iswiz();
< 	extern char *arpadate();
184,187d123
< #if	NeXT_MOD
< 	/* open alias database */
< 	initaliases(AliasFile, FALSE);
< #endif	NeXT_MOD
192,194d127
< #if	NeXT_MOD
< 		setproctitle("From %s", CurHostName);
< #else	NeXT_MOD
196d128
< #endif	NeXT_MOD
205a138
> 	sendinghost = NULL;
226c159
< 			message("421", "%s Lost input channel to %s",
---
> 			message("421", "%s Lost input channel from %s",
231,235d163
< #if	NeXT_MOD
< 		p = grabcommand( inp, &cmd, &c);
< 
< 	      commandloop:
< #else	NeXT_MOD
258c186
< 			if (sameword(c->cmdname, cmdbuf))
---
> 			if (!strcasecmp(c->cmdname, cmdbuf))
261c189
< #endif	NeXT_MOD
---
> 
267,269c195,196
< #if	NeXT_MOD
< 			setproctitle("From %s: %s", CurHostName, inp);
< 			if (sameword(p, MyHostName))
---
> 			setproctitle("%s: %s", CurHostName, inp);
> 			if (!strcasecmp(p, MyHostName))
271,281d197
< 				/* connected to an echo server */
< 				message("553", "%s host name configuration error",
< 					MyHostName);
< 				break;
< 			}
< 			if (RealHostName != NULL)
< 			{
< 				char buf[MAXNAME];
< 				register char *a = CurHostName;
< 				register char *b = p;
< 
283,288c199,200
< 				 * Verify that hostname matches, but accept
< 				 * a leading prefix on a domain boundary,
< 				 * since the network code doesn't know which
< 				 * domain the other guy is in.  E.g. if we are
< 				 * talking to "l5" then it can announce itself
< 				 * as "l5.sun.uucp" and we won't complain.
---
> 				 * didn't know about alias,
> 				 * or connected to an echo server
290,316c202
< 				while (lower(*a) == lower(*b)) {
< 					if (*a == '\0')
< 						break;
< 					a++, b++;
< 				}
< 				if (*a == '\0' &&
< 					(*b == '\0' || *b == '.'))
< 						 goto nameok;
< 				
< 				/*
< 				 * Didn't pass validation.  Use both names.
< 				 */
< 				(void) sprintf(buf, "%s (%s)", p, CurHostName);
< 				define('s', p = newstr(buf), CurEnv);
< 			}
< 			else
< 			{
< 		nameok:
< 				define('s', newstr(p), CurEnv);
< 			}
< #else	NeXT_MOD
< 			setproctitle("%s: %s", CurHostName, inp);
< 			if (sameword(p, MyHostName))
< 			{
< 				/* connected to an echo server */
< 				message("553", "%s I refuse to talk to myself",
< 					MyHostName);
---
> 				message("553", "Local configuration error, hostname not recognized as local");
319c205
< 			if (RealHostName != NULL && !sameword(p, RealHostName))
---
> 			if (RealHostName != NULL && strcasecmp(p, RealHostName))
324c210
< 				define('s', newstr(hostbuf), CurEnv);
---
> 				sendinghost = newstr(hostbuf);
327,328c213
< 				define('s', newstr(p), CurEnv);
< #endif	NeXT_MOD
---
> 				sendinghost = newstr(p);
330c215
< 				MyHostName, p);
---
> 				MyHostName, sendinghost);
338c223
< 				define('s', RealHostName, CurEnv);
---
> 				sendinghost = RealHostName;
346d230
< #if	!(NeXT_MOD)
348a233
> 				errno = 0;
356c241,242
< #endif	!(NeXT_MOD)
---
> 			define('s', sendinghost, CurEnv);
> 			define('r', "SMTP", CurEnv);
358,360d243
< #if	NeXT_MOD
< 			setproctitle("%s From %s: %s", CurEnv->e_id,
< #else	NeXT_MOD
362d244
< #endif	NeXT_MOD
375d256
< #if	!(NeXT_MOD)
378d258
< #endif	!(NeXT_MOD)
383,385d262
< #if	NeXT_MOD
< 			setproctitle("%s From %s: %s", CurEnv->e_id,
< #else	NeXT_MOD
387d263
< #endif	NeXT_MOD
433,435d308
< #if	NeXT_MOD
< 			setproctitle("%s From %s: %s", CurEnv->e_id,
< #else	NeXT_MOD
437d309
< #endif	NeXT_MOD
440,442d311
< #if	NeXT_MOD
< 			SmtpPhase = "wait for quit";
< #endif	NeXT_MOD
464,518d332
< #if	NeXT_MOD
< 			HoldErrs = TRUE;
< 			ErrorMode = EM_MAIL;
< 
< 			CurEnv->e_flags &= ~EF_FATALERRS;
< 
< 			/* 
< 			 * read the next input line to determine what
< 			 * mode to send the mail in.  QUIT means close first
< 			 * and then deliver; otherwise background.
< 			 */
< 			message("250", "Mail accepted");
< 			p = sfgets(inp, sizeof inp, InChannel);
< 			if (p!=NULL)
< 			    p = grabcommand( inp, &cmd, &c);
< 			wasquit = (p == NULL || c->cmdcode == CMDQUIT );
< 			if (wasquit) 
< 			  {
< 			    message("221", "%s delivering mail", MyHostName);
< 			    fclose(InChannel);
< 			    fclose(OutChannel);
< 			  }
< 
< 			CurEnv->e_xfp = freopen(queuename(CurEnv, 'x'), "w", CurEnv->e_xfp);
< 			/* send to all recipients */
< 			sendall(CurEnv, wasquit ? SM_FORK : SM_DELIVER);
< 			CurEnv->e_to = NULL;
< 
< 			hasmail = 0;
< 
< 			/* save statistics */
< 			markstats(CurEnv, (ADDRESS *) NULL);
< 
< 			if (wasquit) 
< 				finis();
< 
< 			dropenvelope(CurEnv);
< 			CurEnv = newenvelope(CurEnv);
< 			CurEnv->e_flags = BlankEnvelope.e_flags;
< 			goto commandloop;
< 
< 		  case CMDRSET:		/* rset -- reset state */
< 		  	hasmail = 0;
< 			Errors = 0;
< 			CurEnv->e_nrcpts = 0;
< 			CurEnv->e_sendqueue = NULL;
< 			message("250", "Reset state");
< 			break;
< 
< 		  case CMDVRFY:		/* vrfy -- verify address */
< 			setproctitle("From %s: %s", CurHostName, inp);
< 			vrfyqueue = NULL;
< 			QuickAbort = TRUE;
< 			sendtolist(p, (ADDRESS *) NULL, &vrfyqueue);
< #else	NeXT_MOD
571d384
< #endif	NeXT_MOD
596d408
< #if	!(NeXT_MOD)
599d410
< #endif	!(NeXT_MOD)
614d424
< #if	!(NeXT_MOD)
617d426
< #endif	!(NeXT_MOD)
622d430
< #if	!(NeXT_MOD)
624d431
< #endif	!(NeXT_MOD)
629d435
< #if	!(NeXT_MOD)
631d436
< #endif	!(NeXT_MOD)
635c440
< # ifdef DEBUG
---
> # ifdef SMTPDEBUG
646d450
< # endif DEBUG
648,656c452
< # ifdef WIZ
< 		  case CMDDBGKILL:	/* kill the parent */
< 			if (!iswiz())
< 				break;
< 			if (kill(MotherPid, SIGTERM) >= 0)
< 				message("200", "Mother is dead");
< 			else
< 				message("500", "Can't kill Mom");
< 			break;
---
> # else /* not SMTPDEBUG */
658,662c454,464
< 		  case CMDDBGWIZ:	/* become a wizard */
< 			if (WizWord != NULL)
< 			{
< 				char seed[3];
< 				extern char *crypt();
---
> 		  case CMDDBGQSHOW:	/* show queues */
> 		  case CMDDBGDEBUG:	/* set debug mode */
> # ifdef LOG
> 			if (RealHostName != NULL && LogLevel > 0)
> 				syslog(LOG_NOTICE,
> 				    "\"%s\" command from %s (%s)\n",
> 				    c->cmdname, RealHostName,
> 				    inet_ntoa(RealHostAddr.sin_addr));
> # endif
> 			/* FALL THROUGH */
> # endif /* SMTPDEBUG */
664,682d465
< 				(void) strncpy(seed, WizWord, 2);
< 				if (strcmp(WizWord, crypt(p, seed)) == 0)
< 				{
< 					IsWiz = TRUE;
< 					message("200", "Please pass, oh mighty wizard");
< 					break;
< 				}
< 			}
< 			message("500", "You are no wizard!");
< 			break;
< 
< # else WIZ
< #if	!(NeXT_MOD)
< 		  case CMDDBGWIZ:	/* try to become a wizard */
< 			message("500", "You wascal wabbit!  Wandering wizards won't win!");
< 			break;
< #endif	!(NeXT_MOD)
< # endif WIZ
< 
687a471
> 			errno = 0;
714d497
< 	extern bool sameword();
738c521
< 	if (!sameword(q, w))
---
> 	if (strcasecmp(q, w))
800,828d582
< **  ISWIZ -- tell us if we are a wizard
< **
< **	If not, print a nasty message.
< **
< **	Parameters:
< **		none.
< **
< **	Returns:
< **		TRUE if we are a wizard.
< **		FALSE if we are not a wizard.
< **
< **	Side Effects:
< **		Prints a 500 exit stat if we are not a wizard.
< */
< 
< #ifdef WIZ
< 
< bool
< iswiz()
< {
< 	if (!IsWiz)
< 		message("500", "Mere mortals musn't mutter that mantra");
< 	return (IsWiz);
< }
< 
< #endif WIZ
< 
< #if	!(NeXT_MOD)
< /*
884c638
< #endif	!(NeXT_MOD)
---
> 
diff -r sendmail.target/src/stab.c sendmail/src/stab.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)stab.c	5.2 (Berkeley) 6/7/85";
< #endif not lint
---
> static char sccsid[] = "@(#)stab.c	5.6 (Berkeley) 1/1/89";
> #endif /* not lint */
48d55
< 	extern bool sameword();
53d59
< # ifdef DEBUG
56d61
< # endif DEBUG
68d72
< # ifdef DEBUG
71d74
< # endif DEBUG
74c77
< 	while ((s = *ps) != NULL && (!sameword(name, s->s_name) || s->s_type != type))
---
> 	while ((s = *ps) != NULL && (strcasecmp(name, s->s_name) || s->s_type != type))
83d85
< # ifdef DEBUG
96d97
< # endif DEBUG
104d104
< # ifdef DEBUG
107d106
< # endif DEBUG
diff -r sendmail.target/src/stats.c sendmail/src/stats.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)stats.c	5.8 (Berkeley) 5/2/86";
< #endif not lint
---
> static char sccsid[] = "@(#)stats.c	5.10 (Berkeley) 6/30/88";
> #endif /* not lint */
20,32d27
< #if	NeXT_MOD
< /*
< **  KBYTES -- given a number, returns the number of Kbytes.
< **
< **	Used in statistics gathering of message sizes to try to avoid
< **	wraparound (at least for a while.....)
< **
< **	Notes:
< **		This function is actually a ceiling function to
< **			the nearest K.
< */
< #define KBYTES(bytes) (((bytes) + 1023) >> 10);
< #else	NeXT_MOD
35d29
< #endif	NeXT_MOD
63,65c57
< **		sfile -- the name of the statistics file,
< **			 or a pointer to an empty string if no statistics
< **			 collection is desired.
---
> **		sfile -- the name of the statistics file.
80,81d71
< #if	NeXT_MOD
< 	int n;
83,91d72
< 	if (sfile == NULL || *sfile == '\0') 
< 		return;
< 
< 	for (n=0; n<MAXMAILERS;n++)
< 	     if (Mailer[n] && Mailer[n]->m_name)
< 		strncpy(Stat.stat_names[n], Mailer[n]->m_name, NAMELEN);
< 	    else
< 		(void) strcpy(Stat.stat_names[n], "");
< #else	NeXT_MOD
94d74
< #endif	NeXT_MOD
diff -r sendmail.target/src/sysexits.c sendmail/src/sysexits.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)sysexits.c	5.2 (Berkeley) 6/7/85";
< #endif not lint
---
> static char sccsid[] = "@(#)sysexits.c	5.5 (Berkeley) 6/30/88";
> #endif /* not lint */
15,16c23
< # include <sysexits.h>
< # include "useful.h"
---
> #include <sysexits.h>
19,23c26,28
< **  SYSEXITS.C -- error messages corresponding to sysexits.h
< */
< 
< char	*SysExMsg[] =
< {
---
>  *  SYSEXITS.C -- error messages corresponding to sysexits.h
>  */
> char *SysExMsg[] = {
37a43
> 	/* 78 CONFIG */		"554 Local configuration error",
40,52c46
< int	N_SysEx = sizeof SysExMsg / sizeof SysExMsg[0];
< /*
< **  STATSTRING -- return string corresponding to an error status
< **
< **	Parameters:
< **		stat -- the status to decode.
< **
< **	Returns:
< **		The string corresponding to that status
< **
< **	Side Effects:
< **		none.
< */
---
> int N_SysEx = sizeof(SysExMsg) / sizeof(SysExMsg[0]);
53a48,59
> /*
>  *  STATSTRING -- return string corresponding to an error status
>  *
>  *	Parameters:
>  *		stat -- the status to decode.
>  *
>  *	Returns:
>  *		The string corresponding to that status
>  *
>  *	Side Effects:
>  *		none.
>  */
58c64
< 	static char ebuf[100];
---
> 	static char ebuf[50];
61,64c67,69
< 	if (stat < 0 || stat >= N_SysEx)
< 	{
< 		(void) sprintf(ebuf, "554 Unknown status %d", stat + EX__BASE);
< 		return (ebuf);
---
> 	if (stat < 0 || stat >= N_SysEx) {
> 		(void)sprintf(ebuf, "554 Unknown status %d", stat + EX__BASE);
> 		return(ebuf);
66,67c71
< 
< 	return (SysExMsg[stat]);
---
> 	return(SysExMsg[stat]);
Only in sendmail/src: tags
diff -r sendmail.target/src/trace.c sendmail/src/trace.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)trace.c	5.2 (Berkeley) 6/7/85";
< #endif not lint
---
> static char sccsid[] = "@(#)trace.c	5.5 (Berkeley) 6/30/88";
> #endif /* not lint */
15d22
< # include <ctype.h>
Only in sendmail.target/src: trace.h
Only in sendmail/src: useful.h
diff -r sendmail.target/src/usersmtp.c sendmail/src/usersmtp.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
10a19
> # include "sendmail.h"
12c21,28
< # include <ctype.h>
---
> #ifndef lint
> #ifdef SMTP
> static char sccsid[] = "@(#)usersmtp.c	5.13 (Berkeley) 1/19/89 (with SMTP)";
> #else
> static char sccsid[] = "@(#)usersmtp.c	5.13 (Berkeley) 1/19/89 (without SMTP)";
> #endif
> #endif /* not lint */
> 
15d30
< # include "sendmail.h"
17,21c32
< # ifndef SMTP
< # ifndef lint
< static char	SccsId[] = "@(#)usersmtp.c	5.7 (Berkeley) 4/2/86	(no SMTP)";
< # endif not lint
< # else SMTP
---
> # ifdef SMTP
23,28d33
< # ifndef lint
< static char	SccsId[] = "@(#)usersmtp.c	5.7 (Berkeley) 4/2/86";
< # endif not lint
< 
< 
< 
42,45d46
< #if	NeXT_MOD
< bool	SmtpLogged;			/* set when logged "connected to" */
< int	SmtpFirstErrno;			/* Meaningful error number */
< #endif	NeXT_MOD
56,57d56
< 
< static greettimeout();
91d89
< #ifdef DEBUG
94d91
< #endif DEBUG
97,100d93
< #if	NeXT_MOD
< 	SmtpFirstErrno = 0;	
< 	SmtpLogged = FALSE;
< #endif	NeXT_MOD
103a97
> 	setproctitle("%s %s: %s", CurEnv->e_id, pvp[1], SmtpPhase);
107d100
< # ifdef DEBUG
111d103
< # endif DEBUG
117,119d108
< #if	NeXT_MOD
< 			extern char *pintvl();
< 			long timeleft;
121,128d109
< 			if (ExitStat==EX_NOHOST) {
< 				fprintf(CurEnv->e_xfp,
< 			"421 Host %s not found for mailer %s.\n",
< 					pvp[1], m->m_name);
< 				return (ExitStat);
< 			}
< #endif	NeXT_MOD
< 
133,135d113
< #if	NeXT_MOD
< 					"%.3s %s via %s... %s",
< #else	NeXT_MOD
137d114
< #endif	NeXT_MOD
141a119
> 				r = errno;
143,155d120
< #if	NeXT_MOD
< 					"421 %s: %s",
< 					pvp[1], errstring(errno));
< 			}
< 			timeleft = CurEnv->e_ctime + TimeOut - curtime();
< 			timeleft = (timeleft+1800)/3600;
< 
< 			if (timeleft > 0)
< 			       fprintf(CurEnv->e_xfp,
< 			         ", will keep trying for %s",
< 				 pintvl(timeleft*3600,FALSE) );
< 			fprintf(CurEnv->e_xfp,"\n");
< #else	NeXT_MOD
157a123
> 				errno = r;
159d124
< #endif	NeXT_MOD
174a140
> 	setproctitle("%s %s: %s", CurEnv->e_id, CurHostName, SmtpPhase);
186a153
> 	setproctitle("%s %s: %s", CurEnv->e_id, CurHostName, SmtpPhase);
231a199
> 	setproctitle("%s %s: %s", CurEnv->e_id, CurHostName, SmtpPhase);
247,249d214
< #if	NeXT_MOD
< 	if (SmtpFirstErrno) errno = SmtpFirstErrno;
< #endif	NeXT_MOD
288a254
> 	setproctitle("%s %s: %s", CurEnv->e_id, CurHostName, SmtpPhase);
291,293d256
< #if	NeXT_MOD
< 	  {
< 		if (SmtpFirstErrno) errno = SmtpFirstErrno;
295,298d257
< 	  }
< #else	NeXT_MOD
< 		return (EX_TEMPFAIL);
< #endif	NeXT_MOD
337a297
> 	setproctitle("%s %s: %s", CurEnv->e_id, CurHostName, SmtpPhase);
340,342d299
< #if	NeXT_MOD
< 	  {
< 		if (SmtpFirstErrno) errno = SmtpFirstErrno;
344,347d300
< 	  }
< #else	NeXT_MOD
< 		return (EX_TEMPFAIL);
< #endif	NeXT_MOD
364a318
> 	setproctitle("%s %s: %s", CurEnv->e_id, CurHostName, SmtpPhase);
367,369d320
< #if	NeXT_MOD
< 	  {
< 		if (SmtpFirstErrno) errno = SmtpFirstErrno;
371,374d321
< 	  }
< #else	NeXT_MOD
< 		return (EX_TEMPFAIL);
< #endif	NeXT_MOD
406,408d352
< #if	NeXT_MOD
< 		SmtpPhase = "final wait";
< #endif	NeXT_MOD
416,418d359
< #if	NeXT_MOD
< 	closeconnection(fileno(SmtpIn));	/* Mark closed in stab */
< #endif	NeXT_MOD
445,448d385
< #if	NeXT_MOD
< 	if (SmtpOut == NULL || SmtpIn == NULL) 
< 		return(SMTPCLOSING);
< #endif	NeXT_MOD
475,491d411
< #if	NeXT_MOD
< 			  /*
< 			   * Make sure we produce a temporary error
< 			   * if the remote end just closed early.
< 			   */
< 			 if (errno==0)
< 			 	errno = ECONNRESET;
< 			if (SmtpFirstErrno==0)
< 				SmtpFirstErrno = errno;
< 			if (errno != ECONNRESET && errno != ETIMEDOUT)
< 				syserr("network read error");
< # ifdef DEBUG
< 			/* if debugging, pause so we can see state */
< 			if (tTd(18, 100))
< 				pause();
< # endif DEBUG
< #else	NeXT_MOD
504d423
< # ifdef DEBUG
508d426
< # endif DEBUG
510c428
< 			syslog(LOG_ERR, "%s", &MsgBuf[4]);
---
> 			syslog(LOG_INFO, "%s", &MsgBuf[4]);
512d429
< #endif	NeXT_MOD
521,531d437
< #if	NeXT_MOD
< 			  /*
< 			   * serious error -- log the previous command 
< 			   * and connection message if needed.
< 			   */
< 			if (SmtpLogged == FALSE && RealHostName) {
< 				SmtpLogged = TRUE;
< 				fprintf(CurEnv->e_xfp, 
< 				  "Connected to %s:\n", RealHostName);
< 			}
< #else	NeXT_MOD
533d438
< #endif	NeXT_MOD
557,562d461
< #if	NeXT_MOD
< 		/* save temporary failure messages for posterity */
< 		if (SmtpReplyBuffer[0] == '4' && SmtpError[0] == '\0')
< 			(void) strcpy(SmtpError, SmtpReplyBuffer+4);
< 
< #endif	NeXT_MOD
571d469
< #if	!(NeXT_MOD)
575c473
< #endif	!(NeXT_MOD)
---
> 
600,603d497
< #if	NeXT_MOD
< 	setproctitle("%s To %s: %s", CurEnv->e_id, 
< 			RealHostName, SmtpMsgBuffer);
< #endif	NeXT_MOD
diff -r sendmail.target/src/util.c sendmail/src/util.c
2,9c2,15
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that this notice is preserved and that due credit is given
>  * to the University of California at Berkeley. The name of the University
>  * may not be used to endorse or promote products derived from this
>  * software without specific prior written permission. This software
>  * is provided ``as is'' without express or implied warranty.
>  *
>  *  Sendmail
>  *  Copyright (c) 1983  Eric P. Allman
>  *  Berkeley, California
>  */
12,13c18,19
< static char	SccsId[] = "@(#)util.c	5.8 (Berkeley) 12/17/85";
< #endif not lint
---
> static char sccsid[] = "@(#)util.c	5.14 (Berkeley) 12/5/88";
> #endif /* not lint */
20d25
< # include <ctype.h>
23,24d27
< static readtimeout();
< 
218c221
< 	while (av && *av != NULL)
---
> 	while (*av != NULL)
245,247c248
< 	if (isascii(c) && isupper(c))
< 		c = c - 'A' + 'a';
< 	return (c);
---
> 	return(isascii(c) && isupper(c) ? tolower(c) : c);
316c317
< 			*p = c - 'A' + 'a';
---
> 			*p = tolower(c);
319,351d319
< **  SAMEWORD -- return TRUE if the words are the same
< **
< **	Ignores case.
< **
< **	Parameters:
< **		a, b -- the words to compare.
< **
< **	Returns:
< **		TRUE if a & b match exactly (modulo case)
< **		FALSE otherwise.
< **
< **	Side Effects:
< **		none.
< */
< 
< bool
< sameword(a, b)
< 	register char *a, *b;
< {
< 	char ca, cb;
< 
< 	do
< 	{
< 		ca = *a++;
< 		cb = *b++;
< 		if (isascii(ca) && isupper(ca))
< 			ca = ca - 'A' + 'a';
< 		if (isascii(cb) && isupper(cb))
< 			cb = cb - 'A' + 'a';
< 	} while (ca != '\0' && ca == cb);
< 	return (ca == cb);
< }
< /*
451c419
< 	if (p[-1] == '\r')
---
> 	if (p > line && p[-1] == '\r')
514d481
< 	register int linelen;
530c497
< 		
---
> 
535c502
< 		
---
> 
546c513
< 		
---
> 
548,564d514
< #ifdef	__STDC__
< 		/*
< 		 * Literal strings aren't writable.
< 		 */
< 		linelen = p - l;
< #if	NeXT_MOD
< 		/*
< 		 * Remove redundant CR characters from the end of lines
< 		 */
< 		while (linelen != 0 && l[linelen-1] == '\r')
< 			linelen--;
< #endif	NeXT_MOD
< 		if (l[0] == '.' && bitnset(M_XDOT, m->m_flags))
< 			(void) putc('.', fp);
< 		fwrite(l, sizeof(char), linelen, fp);
< 		fputs(m->m_eol, fp);
< #else	__STDC__
567,573d516
< #if	NeXT_MOD
< 		  /*
< 		   * Remove redundant CR characters from the end of lines
< 		   */
< 		while (p != l && p[-1] == '\r')
< 			*--p = '\0';
< #endif	NeXT_MOD
579d521
< #endif	__STDC__
628,629c570
< **		none. (not NeXT_MOD)
< **		Errno is set if an error occurs. (NeXT_MOD)
---
> **		none.
634,637d574
< #ifndef ETIMEDOUT
< #define ETIMEDOUT	EINTR
< #endif
< 
647,649d583
< #if	NeXT_MOD
< 	extern int errno;
< #endif	NeXT_MOD
656,669c590,596
< #if	NeXT_MOD
< 			extern char *RealHostName;
< 
< 			errno = ETIMEDOUT;
< 			if (RealHostName) 
< 				syserr("net hang reading from %s",
< 					RealHostName);
< 			else
< 				syserr("input hang");
< 			errno = ETIMEDOUT; /* syserr() resets errno */
< #else	NeXT_MOD
< 			errno = ETIMEDOUT;
< 			syserr("net timeout");
< #endif	NeXT_MOD
---
> # ifdef LOG
> 			syslog(LOG_NOTICE,
> 			    "timeout waiting for input from %s\n",
> 			    RealHostName);
> # endif
> 			errno = 0;
> 			usrerr("timeout waiting for input");
Only in sendmail.target/src: util.c.old
diff -r sendmail.target/src/version.c sendmail/src/version.c
2,9c2,17
< **  Sendmail
< **  Copyright (c) 1983  Eric P. Allman
< **  Berkeley, California
< **
< **  Copyright (c) 1983 Regents of the University of California.
< **  All rights reserved.  The Berkeley software License Agreement
< **  specifies the terms and conditions for redistribution.
< */
---
>  * Copyright (c) 1983 Eric P. Allman
>  * Copyright (c) 1988 Regents of the University of California.
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms are permitted
>  * provided that the above copyright notice and this paragraph are
>  * duplicated in all such forms and that any documentation,
>  * advertising materials, and other materials related to such
>  * distribution and use acknowledge that the software was developed
>  * by the University of California, Berkeley.  The name of the
>  * University may not be used to endorse or promote products derived
>  * from this software without specific prior written permission.
>  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
>  */
12,13c20,21
< static char	SccsId[] = "@(#)version.c	5.52 (Berkeley) 5/6/86";
< #endif not lint
---
> static char sccsid[] = "@(#)version.c	5.61 (Berkeley) 9/20/88";
> #endif /* not lint */
15c23
< char	Version[] = "NeXT-0.8";
---
> char	Version[] = "5.61";
