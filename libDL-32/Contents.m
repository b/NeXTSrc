/*
 * Build the table of contents window.
 * This contains the copyright notice and a viewer for ancillary
 * parts of the dictionary.
 */

#import <appkit/appkit.h>

#import <stdio.h>
#import <string.h>

#import "Contents.h"
#import "SplitView.h"
#import "QueryField.h"
#import "NroffText.h"
#import "bitmap.h"
#import "SummaryMatrix.h"
#import "Find.h"
#import "aux.h"
#import "confirm.h"

#import <text/text.h>   

@implementation Contents 

#define obj(x,y)  NXGetNamedObject(x,y)

#define NFILES 64

static int numFiles = 0;
static char *FileName[NFILES];
static int Files[NFILES];
static int curFile = -1;
static Index *infoIndex = (Index *)0;

- print:sender
{
	id p = [NXApp printInfo];
	[p setHorizCentered:NO];
	[p setVertCentered:NO];

	[fileText printPSCode:self];
	return self;
}

static
setFile(id window, id view, id splitView, char *s, char *infoPath)
{
	char t[1024];
#if 0
	id sv;
#endif

	NXStream *f=NXMapFile(s, NX_READONLY);
	if (!f) {
		sprintf(t,"%s/%s",infoPath,"noop");
		f = NXMapFile(t,NX_READONLY);
	}
	if (f){
	    [window disableFlushWindow];
	    [window disableDisplay];
	    [view setText:NULL];
#if 0
	    sv = [view superview];
	    [view removeFromSuperview];
	    [view setAutodisplay:NO];
#endif
	    [view readRichText:f];
	    NXCloseMemory(f, NX_FREEBUFFER);
#if 0
	    [view setAutodisplay:YES];
	    [sv addSubview:view];
#endif
	    [window reenableDisplay];
	    [splitView refreshText:view];
	    [window reenableFlushWindow];
	    [window flushWindow];
	}
}

- setFile:(char *)s {
	setFile(window, fileText, splitView, s, infoPath);
	return self;
}
    
- nthFile:(int)n {
	[summary hilite:n];
}

- (int) nextFile {
	static int recursing = 0;
	static int lastFile;

	if (!recursing) lastFile = curFile;	/* make sure you don't reset to
						 * the current file */

    	while (++curFile < NFILES && !Files[curFile])
		;
	if (curFile >= NFILES) {
		if (recursing) return 0;
		curFile = -1;	/* wrap around */
		recursing++;
		return [self nextFile];
	}
	recursing = 0;
	if (curFile != lastFile)
		[self nthFile:curFile];
	[fileText setSel:0:0];
	return 1;
}

- (int) prevFile {
	static int recursing = 0;
	static int lastFile;

	if (!recursing) lastFile = curFile;	/* make sure you don't reset to
						 * the current file */

    	while (--curFile >= 0 && !Files[curFile])
		;
	if (curFile < 0) {
		if (recursing) return 0;
		curFile = NFILES;	/* wrap around */
		recursing++;
		return [self prevFile];
	}
	recursing = 0;
	if (curFile != lastFile)
		[self nthFile:curFile];
	[fileText setSelEnd];
	return 1;
}

static int intr() { return NO; }

    - (int) setFilesFromIndex:(char *)str {
        RefList r;
	int i,j;
	char s[1024];

    	if (!infoIndex) infoIndex = ixOpen(infoPath,"r");
	if (!infoIndex) return 0;
	r.n = 0;
	if (!ixGetRefList(infoIndex, str, &r, ixSearchByFullWord, intr))
		return 0;
	/* don't need to sort it */
	for (i=0;i<r.n;i++){
	    strcpy(s,ixFullPath(infoIndex, r.r[i].f->file));
	    for (j=0;j<numFiles;j++)
		    if (strcmp(FileName[j],s)==0)
			    Files[j]=1;
	}
	ixClearRefList(&r);
	return 1;
    }
    
    - setFiles:(char *)str
    /*
     * User has just typed a search string.
     * set File[n] to true if the nth file contains the find text
     */
    {
    	int i,n=0;
	FILE *f;
	char s[1024];
	
	curFile = -1;
	bzero(Files,numFiles*sizeof(int));
	n = [self setFilesFromIndex:str];
	if (!n){
	    sprintf(s,"fgrep -l -i \"%s\" %s/[a-z]*", str, infoPath);
	    f = popen(s,"r");
	    if (!f){
		    return ;
	    }
	    while (fgets(s,sizeof s,f)){
		    index(s,'\n')[0] = '\0';
		    for (i=0;i<numFiles;i++)
			    if (strcmp(FileName[i],s)==0)
				    Files[i]=n=1;
	    }
	    pclose(f);
	}
	if (n) [self nextFile];
	else error("\"%s\" not found.", str);
    }
    
#define MAXSTR 250

- search:(id)sender {
	return [findPanel() search:sender in:self];
}

- (int)findText:(char *) str forward:(BOOL)fwd {
	int found;
	static char prev[MAXSTR];

	if (!str || !*str ) return NO;
	
	/* if it's not the same as the last time,
	 * then find out what files have the word
	 */
	if (strncmp(prev, str, MAXSTR - 1)){
		strncpy(prev, str, MAXSTR - 1);
		[self setFiles:str];
	}

	found = [fileText findText:str forward:fwd];
	if (!found && (fwd ? [self nextFile] : [self prevFile])) {
		return [self findText:str forward:fwd];
	}
	return found;
}

- free {
	[window free];
	[splitView free];
	[summary free];
	[fileText free];
	if (infoPath) free (infoPath);
	return [super free];
}

/* instance variables */
- contentsText {return fileText;}
- window {return window;}


/* internal methods */

#define PAD 8.0
#define PAD2 16.0
#define DX 520.0
#define DY 300.0

- buildnib
/* Generated by the NeXT Interface Builder */
{
	id	theWindow, theView, theItem;
	NXRect	theFrame;

	NXSetRect(&theFrame, 525.0, 500.0, DX, DY);
	theWindow = [Window newContent:&theFrame
			style:NX_TITLEDSTYLE
			backing:NX_BUFFERED
			buttonMask:NX_CLOSEBUTTONMASK|NX_RESIZEBUTTONMASK
			defer:NO];
	NXNameObject("Contents", theWindow, NXApp);
	[theWindow setTitle:"Contents"];
	theFrame.origin.x = theFrame.origin.y = 0.0;
	theView = [View newFrame:&theFrame];

	NXSetRect(&theFrame, PAD, 0.0, DX-PAD2, DY-PAD);
	theItem = [SplitView newFrame:&theFrame];
	[theView addSubview:theItem];
	NXNameObject("splitView", theItem, theWindow);

	theFrame.origin.y = theFrame.size.height = 112.0;
	theItem = [SummaryMatrix newFrame:&theFrame];
	[theView addSubview:theItem];
	NXNameObject("Summary", theItem, theWindow);

	theFrame.size.height = theFrame.origin.y;
	theFrame.origin.y = 0.;
	theItem = [NroffText newFrame:&theFrame];
	[theItem setDoAlert:NO];
	[theView addSubview:theItem];
	NXNameObject("Contents", theItem, theWindow);

	[theWindow setContentView:theView];
	return theWindow;
}

- loadContents {
	FILE *f;
	char s[1024], name[1024], desc[1024];
	
	sprintf(s,"%s/Contents", infoPath);
	if (f=fopen(s,"r")){
		while (fscanf(f,"%[^\t]%*[\t]%[^\n] ",name,desc)==2){
			sprintf(s,"%s/%s",infoPath,name);
			[summary addCell:strsave(desc):
				FileName[numFiles]=strsave(s) :0:0:0];
			numFiles++;
		}
		fclose(f);
		[summary sizeToFit];
		[splitView refreshText:summary];
	}
}

- hookupUI {
	window = obj("Contents",NXApp);
		[window setFreeWhenClosed:NO];

	splitView = obj("splitView",window);
	summary = obj("Summary",window); {
		[splitView addView:summary height:100. divider:YES];
	}
	
	fileText = obj("Contents",window); {
		[splitView addView:fileText divider:YES];
		[fileText setEditable:NO];
		[fileText setWrapAround:NO]; /* default is YES */
		[splitView setMinHeight:fileText:100.0];
	}
	[self loadContents];
	fixScrolls(fileText,splitView);
	fixScrolls(summary,splitView);
	[[window contentView] setAutoresizeSubviews:YES];
}

- windowWillResize:sender toSize:(NXSize *)frameSize; {
	if (frameSize->width < 300.)
		frameSize->width = 300.;
	if (frameSize->height < 250.)
		frameSize->height = 250.;
	return self;
}

+ new:(char *)path
{
	self = [super new];
	self->infoPath = strsave(path);
	[self buildnib];
	[self hookupUI];
	[window display];
	[[self window] setDelegate:self];
	return self;
}

+ show:(char *)path {
	static id currObj = nil;

	if (!currObj || strcmp(currObj->infoPath, path)) {
		if (currObj) [currObj free];
		currObj = [Contents new:path];
	}
	self = currObj;

	[window makeKeyAndOrderFront:self];
	return self;
}

@end
