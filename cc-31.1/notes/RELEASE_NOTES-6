
cc-6 internal release of the Objective-C compiler
-------------------------------------------------

cc-6 is the first release of the NeXT/GNU implementation of the 
Objective-C language. cc-6 is a `real' compiler...it is faster and 
smarter than the 0.8 translator.

Compatibility issues
--------------------

* Source files:

  You will get a syntax error if the following constructs are used.

  - `cc-6' does not recognize the following 3.3 constructs:

    @requires, @classes, @messages, =, = ( ... ).

  - `cc-6' does not support method prototypes that are not in the context
    of an interface declaration.

  - `cc-6' does not support static typing/allocation/binding of objects.
    this will be supported in `cc-7'.

  You will get a semantic error if the following items do not conform.

  - `cc-6' does not allow tagged structure definitions to appear in BOTH
    the interface and implementation instance variable declaration lists,
    untagged structure definitions are permitted.

  - `cc-6' requires that methods with variable arguments conform to the
    ANSI standard. 

* Object files:

  - `cc-6' is object code incompatible with the 0.8 release of the
    Objective-C translator.

  YOU MUST RECOMPILE ALL OBJECT MODULES THAT CONTAIN OBJECTIVE-C CODE.

* Archive files:

  - <see bug #1>

* Misc:

  - `cc-6' does not insert a call to `_objcInit()' in the prologue code
    for `main()'. all this means (from the users perspective) is that 
    `main()' is no longer required to reside in a `.m' file.

* Compiler Options:

  - `cc-6' does not support the `-K', `-Retain' options. These options
    caused the compiler to retain the C program that was generated by the
    translator. Since the compiler generates assembly code, `-S' must suffice. 

  - `cc-6' does not support the `lineMax:<n>' option. Lines are now of 
    arbitrary length, this was not the case in 0.8.

Some bugs that have been fixed
------------------------------

1) incorrect type encoding for some complex types - this effects archiving.

	@interface Bug : Object
	  {
		char *(*ptrToFuncRetPtrToChar)();
		float *aryOfPtrToFlts[7];
	  }

   cc-5 gets this wrong. it generates the following: "#*[3f]"
   cc-6 gets this right. it generates the following: "#$$"

   fixing this bug in the compiler implies that archive files must also
   be fixed. If you are responsible for a class that archives one of the 
   above types, you will have to teach your class how to convert from the 
   0.8 world to the 0.9 world. This is typically done in the 
   `readSelf:archiver', `writeSelf:archiver' methods.

2) incorrect error message "Array subscript has undefined value" when
   using an enum constant as an array dimension for instance variables. 

	typedef enum _example { myEnumConstant = 7 } example;

	@interface Example : Object
	  {
		unsigned instVar[myEnumConstant];
	  }

   In general, any annoying warning/error messages that were being issued
   incorrectly by the 0.8 translator will no longer by a problem.

3) the GNU extension `static inline' is now allowed in an Objective-C
   program. This means you can now use the original prototypes defined
   in /usr/include/math.h.
   
4) compiler aborts when casting sizeof expressions in an `.m' file.

Known Problem
-------------

1) null characters in your source file trick the compiler into thinking
   is has encountered an EOF. This will cause one of two things to happen. 
   
   - if it appears in a `syntactically inappropriate' place, you
     will get a syntax error, for example:

	main() { ^@ }

     causes the compiler to issue the following message:

     In function main:
     foo.m:1: parse error at end of input

   - if it appears in a `syntactically appropriate' place, the compiler 
     will just exit, causing the linker some grief. for example:

	^@ main() { }

     causes the linker to issue the following message:

     Undefined symbols:
     _main

     if you are not using an editor that displays control characters, 
     this can be very confusing...this will be fixed in cc-7.
